# B-Tree
데이터베이스에서 인덱스는 책의 목차처럼 원하는 데이터를 빠르게 찾기 위한 구조다. 인덱스가 없다면 테이블 전체를 처음부터 끝까지 탐색해야 하는데(Full Scan), 데이터가 많아질수록 속도가 급격히 느려진다. 그래서 검색, 삽입, 삭제 성능이 모두 일정하게 빠른 자료구조가 필요한데, 그 답이 바로 B-Tree 계열 트리다.

## B-Tree란?
- B-Tree는 균형 다진 트리(Balanced M-ary Tree)
- 모든 노드가 여러 개의 키와 자식을 가질 수 있고, 항상 균형을 유지
- 루트, 내부 노드, 리프 노드 모두에 데이터(키 + 실제 데이터 주소)가 저장될 수 있음이 특징
- 검색, 삽입, 삭제 모두 평균 O(log n)의 시간 복잡도를 보장

```text
          [10 | 20]
        /    |    \
 [1, 5, 7] [11,15] [21,25,30]
```
루트 노드에 10, 20이 저장되어 있고 리프 노드에도 1, 5, 7 같은 데이터가 들어있음.

## B+Tree란?
- B+Tree는 B-Tree를 개선한 구조로, MySQL의 innoDB 인덱스에서 사용
- 내부 노드에는 키 값만 저장하고, 실제 데이터 주소는 리프 노드에만 저장
- 리프 노드들은 Linked List 형태로 연결되어 있어서 범위 검색(Range Scan)에 매우 효율적

```text
         [10 | 20]
        /     |     \
    [1,5,7] [11,15] [21,25,30]
      |        |         |
 (실데이터) -> (실데이터) -> (실데이터)
```
루트와 내부 노드는 단순히 "길잡이" 역할만 하고 진짜 데이터 위치(주소)는 리프 노드에만 저장. 리프 노드들이 서로 연결되어 있어서 예를 들어 WHERE age BETWEEN 20 AND 30 같은 쿼리를 실행할 때 빠르게 연속해서 데이터를 읽을 수 있음.


| 구분        | B-Tree             | B+Tree            |
| --------- | ------------------ | ----------------- |
| 데이터 저장 위치 | 모든 노드(루트, 내부, 리프)  | 리프 노드에만 저장        |
| 리프 노드 연결  | 없음                 | Linked List로 연결   |
| 범위 검색 성능  | 상대적으로 비효율적         | 매우 효율적            |
| 사용 사례     | 예전 파일시스템, DB 초기 버전 | **현대 DB 인덱스의 표준** |