# 인덱스 최적화 기법

## 좋은 Primary Key(Clustered Index) 설계
- 짧고, 단순하며, 단조 증가하는 값을 PK로 선택
- Auto Increment 숫자 → 삽입 시 정렬 유지 비용 최소화
- UUID 같은 랜덤 값 → 중간 삽입 발생 → Page Split, 성능 저하
- PK 크기가 클수록 모든 Secondary Index도 커지므로 PK는 최대한 짧게 유지

## 필요한 컬럼에만 인덱스 생성
- 인덱스는 조회 성능을 높이지만, INSERT/UPDATE/DELETE 시에는 인덱스도 함께 갱신해야 함 → 쓰기 성능 저하
- 자주 쓰는 WHERE, JOIN, ORDER BY, GROUP BY 컬럼 위주로 인덱스 생성
- 단순히 “자주 쓰이는 컬럼”이 아니라, 카디널리티(값의 다양성) 가 높은 컬럼이 효과적
    - 예: gender(남/여)는 값이 2개뿐 → 인덱스 효과 미미
    - email 같은 유니크 값은 인덱스 효과

## 복합 인덱스(Composite Index) 활용
- 여러 조건이 자주 함께 사용된다면 복합 인덱스가 효과적

```sql
    CREATE INDEX idx_user_name_email ON users(name, email);
```

- 주의: 왼쪽부터 사용 가능. 인덱스는 왼쪽 컬럼의 정렬에 의존적.
    - WHERE name = ? : 인덱스 활용 가능
    - WHERE email = ? : 인덱스 활용 불가 (name 먼저 있어야 함)
- 따라서, 자주 쓰이는 조건 순서로 인덱스 컬럼을 배치하는 게 중요

## 커버링 인덱스(Covering Index)
- 쿼리에서 필요한 컬럼이 모두 인덱스 안에 포함돼 있다면, 테이블 접근 없이 인덱스만으로 결과 반환 가능
```sql
CREATE INDEX idx_email_name ON users(email, name);
SELECT email, name FROM users WHERE email = 'test@test.com';
```
- Clustered Index 접근 불필요 → 성능 ↑

## LIKE 최적화
- LIKE 'abc%' → 인덱스 사용 가능 (접두어 검색)
- LIKE '%abc' 또는 LIKE '%abc%' → 인덱스 사용 불가 (앞이 와일드카드면 B+Tree 탐색 불가)
- 해결 방법:
    - FULLTEXT INDEX 활용 (전문 검색)
    - 검색 엔진(ElasticSearch 등) 연동 고려

