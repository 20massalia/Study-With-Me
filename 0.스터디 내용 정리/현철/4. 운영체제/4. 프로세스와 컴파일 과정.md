# 프로세스와 컴파일 과정

프로그래밍을 할 때 보통 `.c`, `.cpp`, `.java` 같은 소스 파일을 작성하고, 빌드 버튼을 누르면 실행 파일이 만들어진다.
하지만 이 과정 뒤에서는 여러 단계의 변환과 결합이 차례대로 이루어진다. 바로 전처리 → 컴파일러 → 어셈블러 → 링커 과정이다.

## 1. 전처리(Preprocessing) — 소스 코드 전 정리
전처리는 소스 코드가 컴파일되기 전에 미리 처리되는 작업을 말한다. C/C++에서 #include, #define, #ifdef 같은 지시문이 여기서 처리된다.

- 헤더 파일 포함 처리 (#include)
- 매크로 치환 (#define)
- 조건부 컴파일 (#ifdef, #ifndef)

전처리의 결과물은 확장된 소스 코드이며, 여전히 사람이 읽을 수 있는 형태다.

## 2. 컴파일러(Compiler) — 고급 언어를 어셈블리로 변환
컴파일러는 전처리가 끝난 소스 코드를 분석해 `어셈블리어(Assembly)`로 변환한다. 이 과정에서 문법 검사, 최적화, 코드 생성이 이루어진다.

- 어휘 분석(Lexical Analysis) : 코드의 단어(토큰)를 분리
- 구문 분석(Syntax Analysis) : 문법 규칙에 맞는지 확인
- 최적화(Optimization) : 실행 속도나 크기 개선
- 코드 생성(Code Generation) : 어셈블리 코드로 변환

이 단계의 결과물은 .s 확장자의 어셈블리 파일이다.

## 3. 어셈블러(Assembler) — 어셈블리를 기계어로 변환
어셈블러는 .s 파일을 받아 ``목적 코드(Object Code)`로 변환한다. 여기서 목적 코드는 CPU가 이해할 수 있는 기계어(Binary)이지만, 아직 완전한 실행 파일은 아니다.
이 과정에서 만들어진 .o(또는 .obj) 파일에는 심볼 정보(함수, 변수 이름 등)가 포함되어 있다.

## 4. 링커(Linker) — 목적 코드를 하나로 결합
링커는 여러 개의 .o 파일과 라이브러리를 하나의 실행 파일로 합친다. 이 과정에서 각 목적 코드의 심볼들이 연결(Resolve)된다.

- 심볼 해석(Symbol Resolution) : 함수, 변수의 참조를 실제 정의로 연결
- 재배치(Relocation) : 실행 시 올바른 메모리 주소를 가리키도록 조정
- 라이브러리 연결 : 표준 라이브러리(printf, malloc 등) 포함

최종적으로 .exe(Windows)나 ELF(Linux) 같은 실행 가능한 바이너리가 생성된다.

```text
소스 코드(.c)
   ↓ 전처리기(Preprocessor)
전처리된 코드(.i)
   ↓ 컴파일러(Compiler)
어셈블리 코드(.s)
   ↓ 어셈블러(Assembler)
목적 코드(.o)
   ↓ 링커(Linker)
실행 파일(a.out, exe)
```

## 프로세스와의 연결
위에서 생성된 실행 파일은 디스크에 저장된 정적인 프로그램이다. 실제로 프로그램을 실행하면 운영체제가 이 파일을 읽어 ``프로세스(Process)``로 메모리에 적재하고, CPU가 명령어를 실행하게 됩니다.

- 컴파일 과정은 실행 파일을 만드는 준비 단계
- 프로세스는 그 실행 파일이 실제 메모리에서 실행되는 상태라고 볼 수 있다.