# 프로세스의 상태
프로그램이 실행되면 운영체제(OS)는 해당 프로그램을 `프로세스(Process)`라는 단위로 관리한다.
하지만 프로세스는 단순히 "실행 중"만 있는 것이 아니라, 상황에 따라 여러 `상태(State)`를 오간다.

## 1. 생성(New)
프로세스가 처음 만들어지는 단계.
운영체제가 실행 요청을 받아 PCB(Process Control Block)를 생성하고, 메모리 공간을 할당한다

- 예시: 사용자가 프로그램 실행 버튼을 눌렀을 때
- 상태 변화: 생성 → 준비(Ready)

## 2. 준비(Ready)
프로세스가 CPU를 사용할 준비가 되었지만, CPU가 아직 다른 일을 처리 중이라 대기하는 상태.
메모리에는 로드되어 있지만, CPU 스케줄러가 실행 순서를 정할 때까지 기다린다.

- 예시: 여러 프로그램이 동시에 실행될 때, 대기열에서 CPU 순번을 기다리는 상태
- 상태 변화: 준비 → 실행(Running)

## 3. 실행(Running)
CPU를 점유하여 명령어를 실제로 수행하는 상태 프로세스는 이 상태에서만 CPU 연산을 수행한다.

- 상태 변화:
    - 실행 → 준비 (더 높은 우선순위 프로세스 등장 또는 타임 슬라이스 종료)
    - 실행 → 대기 (입출력 요청 발생)

## 4. 대기(Waiting / Blocked)
프로세스가 CPU를 사용하지 못하고, 특정 이벤트나 입출력(I/O) 작업이 끝나길 기다리는 상태

- 예시: 파일 읽기/쓰기, 네트워크 응답 대기
- 상태 변화: 대기 → 준비 (이벤트 완료 시)

## 5. 종료(Terminated)
프로세스의 작업이 모두 끝나거나, 강제 종료된 상태. 운영체제는 할당된 자원을 회수하고 PCB를 삭제합니다.

```text
 [생성] → [준비] ↔ [실행] → [종료]
           ↑       ↓
            ← [대기]
```

> 입출력 요청이 발생해도 준비 상태로 돌아가도 될텐데 왜 대기 상태가 필요할까?
> 
> 대기(Waiting) 상태가 필요한 이유는 입출력(I/O) 작업의 특성과 CPU 사용 방식이 다르기 때문이다.
> 간단히 말하면, CPU만 쓰는 일과 I/O를 기다리는 일은 성격이 완전히 달라서 구분해야 한다.
> 1. CPU는 "계속 계산", I/O는 "기다림"
>   - 준비(Ready) 상태는 “CPU를 쓸 준비가 다 됐다”는 뜻.
>   - 그런데 I/O 요청은 CPU를 사용하지 않는다.
>       - 예: 디스크에서 데이터를 읽는 동안 CPU는 할 일이 없음
>   - 만약 I/O 작업이 끝나지 않았는데 준비 상태에 넣어버리면,
>       - 스케줄러가 CPU를 할당해도 할 일이 없는 프로세스가 실행됨 → CPU 낭비
> 
> 2. 대기 상태는 자원 관리에 필수
>   - 운영체제는 준비 상태 큐(Ready Queue)와 대기 상태 큐(Wait Queue)를 분리해서 관리
>       - Ready Queue: CPU 자원을 기다리는 프로세스
>       - Wait Queue: 특정 이벤트(입출력 완료, 신호 등)를 기다리는 프로세스
>   - 이렇게 나누면 스케줄러가 `CPU를 당장 쓸 수 있는 프로세스`만 빠르게 골라낼 수 있다.
> 3. 비효율 방지
>   - 만약 대기 상태 없이 전부 준비 큐에 넣는다면:
>   1. 스케줄러가 준비 큐에서 실행할 프로세스를 고름
>   2. I/O 대기 중인 프로세스가 선택됨
>   3. 실행 직후 “아, I/O 아직 안 끝났네” 하고 다시 쉬러 감 → 컨텍스트 스위치 비용만 낭비

