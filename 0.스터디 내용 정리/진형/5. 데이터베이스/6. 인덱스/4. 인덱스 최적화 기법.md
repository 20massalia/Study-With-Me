# ✏️ 인덱스 최적화 기법

데이터베이스의 인덱스 최적화는 성능 향상 및 쿼리 응답 시간 단축을 목표로
합니다.\
주요 기법들을 정리하면 다음과 같습니다.

------------------------------------------------------------------------

## 📌 적절한 인덱스 선택

**예시**

``` sql
SELECT * FROM orders WHERE customer_id = 123;
```

-   인덱스 없이: 모든 레코드를 검사 (**Full Table Scan**) → 비효율적\
-   인덱스 있음: customer_id 값이 123인 위치를 빠르게 찾음 → 효율적

👉 자주 사용되는 조건 컬럼에 인덱스를 생성하자.

------------------------------------------------------------------------

## 📌 복합 인덱스 사용

**예시**

``` sql
SELECT * FROM orders 
WHERE customer_id = 123 
AND order_date > '2023-01-01';
```

-   단일 인덱스(customer_id만): 먼저 customer_id로 찾고, 이후
    order_date는 테이블에서 필터링 → 느림\
-   복합 인덱스(customer_id, order_date): 두 조건을 동시에 활용하여 빠른
    검색 가능

👉 WHERE 절에 여러 조건이 자주 사용된다면 복합 인덱스를 고려.

------------------------------------------------------------------------

## 📌 인덱스 크기 최적화

**예시**\
긴 URL 컬럼 `website_url`에 인덱스를 걸면 인덱스 크기가 커져 성능 저하
가능.

**해결 방안** - URL 전체가 아닌, 앞 50자 정도만 인덱싱\
- 대부분의 경우 앞부분만으로도 충분히 구분 가능

------------------------------------------------------------------------

## 📌 분할 인덱스 (Partitioning)

**예시**: 매년 거래 데이터가 저장되는 `transactions` 테이블 → 연도별
파티션 생성

-   문제: 수백만 건의 데이터를 한 번에 검색하면 성능 저하\
-   해결: 연도별 파티션 → 특정 연도만 검색 시 빠른 조회 가능

**장점** - 특정 파티션만 탐색 → 검색 시간 단축\
- 오래된 데이터 삭제 시 해당 파티션만 삭제 → 관리 용이

------------------------------------------------------------------------

## 📌 인덱스 정비

**예시**

``` sql
OPTIMIZE TABLE table_name;
```

-   MySQL에서 인덱스를 재구성하고 **파편화(Fragmentation)** 를 줄임

------------------------------------------------------------------------

## 📌 쿼리 최적화

**예시 (비효율적)**

``` sql
SELECT * FROM users WHERE YEAR(birthdate) = 1990;
```

👉 인덱스 사용 불가

**개선 (효율적)**

``` sql
SELECT * FROM users 
WHERE birthdate BETWEEN '1990-01-01' AND '1990-12-31';
```

👉 인덱스 활용 가능

------------------------------------------------------------------------

## 📌 Covering Index 사용

**예시**

``` sql
SELECT customer_id, order_date 
FROM orders 
WHERE customer_id = 123;
```

-   (customer_id, order_date) 복합 인덱스가 있다면,\
    인덱스 자체만으로 결과 반환 가능 (테이블 접근 불필요).

👉 Covering Index는 특정 쿼리의 성능을 크게 향상시킬 수 있다.

------------------------------------------------------------------------

## 📌 인덱스의 데이터 타입 일치

**예시 (비효율적)**

``` sql
WHERE age = '25'  -- age가 INTEGER인데 문자열 비교
```

👉 인덱스 사용 비효율적

**개선 (효율적)**

``` sql
WHERE age = 25
```

👉 타입을 일치시켜 인덱스를 최적 활용

------------------------------------------------------------------------
