# 📌 인덱스 (Index)

인덱스는 데이터 레코드를 빠르게 접근하기 위해서 **\<키, 포인터\>
쌍**으로 구성되는 데이터 구조이다.

- 테이블에 데이터가 저장될 때, 특정한 PK 값을 찾기 위해 매번 접근하는
  것은 비효율적이다.\
- 따라서, PK 값과 해당하는 데이터 row의 주소를 자료구조로 묶어서
  저장하는 것이 인덱스이다.\
- 인덱스는 대용량 데이터에서 **검색 속도 향상**을 목적으로 한다.\
- 인덱스로 설정되지 않은 컬럼을 조회할 경우 **Full Scan(Table Scan)**
  이 발생하여 속도가 저하된다.

---

## 📖 인덱스 생성 시 주의점

- 무작정 인덱스를 생성한다고 항상 성능이 좋아지지 않는다.\
- 인덱스를 생성하면 인덱스를 위한 **디스크 공간**이 필요하다.\
- DML(INSERT, DELETE, UPDATE) 작업 시 **추가적인 비용**이 발생한다.\
- 따라서 테이블의 특성과 조회 의도를 고려하여, **Clustered Index**와
  **Non-Clustered Index**를 적절히 구성해야 한다.

### DML (Data Manipulation Language)

데이터를 조작하는 명령어: `INSERT`, `DELETE`, `UPDATE`

---

## 📚 책에 비유하자면

- **클러스터 인덱스** → 원하는 페이지를 바로 펴는 것\
- **넌 클러스터 인덱스** → 목차에서 페이지를 찾아 이동하는 것\
- **테이블 스캔** → 책을 처음부터 한 장씩 넘기며 찾는 것

---

# 📖 클러스터 인덱스 (Clustered Index)

Clustered Index는 **행 데이터를 특정 열 기준으로 정렬**하여 구성한다.\

- Root 페이지와 Leaf 페이지로 이루어진 **트리 구조**로 저장된다.\
- Root 페이지는 Leaf 페이지의 주소, Leaf 페이지는 실제 데이터 페이지로
  구성된다.\
- 별도의 인덱스 페이지를 만들지 않는다.\
- **테이블당 단 하나만 존재**한다.\
- 클러스터드 인덱스를 지정하지 않으면 기본 키(PK)가 자동으로 클러스터드
  인덱스가 된다.

### 🌟 데이터 검색 순서

`Root 페이지 → Leaf 페이지(데이터 페이지)`

### 📚 생성하기 좋은 경우

- 테이블 데이터가 자주 업데이트되지 않는 경우\
- `MAX`, `MIN`, `COUNT` 등의 범위/그룹 조회가 많은 경우\
- 항상 정렬된 데이터를 반환해야 하는 경우\
- 읽기 작업이 많을 때 매우 유리

### 📚 단점

- 새로운 데이터 삽입 시 **페이지 분할(Page Split)** 발생 가능\
- 데이터 입력, 수정, 삭제 시 성능 저하\
- 항상 정렬 상태를 유지해야 하므로 관리 비용이 크다

---

# 📖 넌 클러스터 인덱스 (Non-Clustered Index)

Non-Clustered Index는 **원본 데이터는 정렬하지 않고**, 별도의 **인덱스
페이지**를 만든다.

- 인덱스 페이지의 리프 페이지에 정렬된 키와 **포인터(RID)** 를
  저장한다.
- RID: `파일그룹번호 + 데이터페이지번호 + 페이지 내 로우번호`
- 데이터 페이지는 그대로 두고 인덱스 페이지를 추가 생성하므로 **추가
  공간이 필요**하다.
- 테이블당 약 **240개까지 생성 가능**하다.

### 🌟 데이터 검색 순서

`Root 페이지 → 리프 페이지 → 데이터 페이지(Heap page)`

### 📚 생성하기 좋은 경우

- `WHERE`, `JOIN` 조건으로 자주 사용하는 컬럼\
- 데이터가 자주 업데이트되는 경우\
- 특정 컬럼이 쿼리에서 자주 사용되는 경우

### 📚 단점

- 인덱스만을 위한 **추가 저장 공간** 필요\
- 데이터 삽입 시 별도 인덱스 페이지 작업 필요\
- 클러스터 인덱스보다 데이터 접근 속도가 상대적으로 느림\
- 검색 시 단계가 많아 비용 증가\
- 클러스터 인덱스 변경 시 연쇄적으로 업데이트 발생

---
