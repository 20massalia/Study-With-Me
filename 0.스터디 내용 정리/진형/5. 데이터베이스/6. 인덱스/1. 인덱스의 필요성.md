# . 인덱스(Index)의 필요성

## 인덱스의 정의

> 데이터베이스에서 테이블의 검색 성능을 높여주는 방법.
> 관계형 데이터베이스에서는 B+Tree 구조로 된 index 를 사용하여 검색 속도를 향상시킨다.
> 특히 select ~ where 쿼리처럼 특정 데이터를 찾을 때 빠른 속도로 검색할 수 있게 해준다

---

## 인덱스의 장단점

- 장점 : 빠른 검색 속도 향상
- 단점 : 추가 저장공간이 필요하다는 점.  (약 10%)
그리고 insert, update, delete 등의 변동 사항이 있는 경우 성능이 저하됨.
왜냐하면 데이터 변경 시 인덱스도 수정되어 추가 비용이 발생하기 때문이다.

---

## 인덱스를 사용하는 컬럼

- 인덱스는 where 절에서 **자주 조회** 하고 **수정 빈도**가 낮으며 **데이터 중복**이 적은 컬럼을 선택하는 것이 좋다.
join 조건으로 자주 사용되는 컬럼도 인덱스로 사용하면 좋다. 데이터의 양이 많을수록 인덱스 성능 향상이 커진다.

- 단, 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요시간이 커집니다.
또한 성별처럼 데이터 중복이 높은 값은 인덱스를 생성하지 않는 것이 크게 의미가 없습니다.
왜냐하면 인덱스의 이점보다 추가 저장공간이나 데이터 수정에 대한 성능 저하가 더 크기 때문입니다.

---

## 해시 테이블(Hash Table)

해시 테이블은 **(Key, Value)** 로 데이터를 저장하는 자료구조 중 하나로  
빠른 데이터 검색이 필요할 때 유용하다.

해시 테이블은 Key값을 이용해 고유한 Index를 생성하여,  
그 Index에 저장된 값을 꺼내오는 구조이다.

DB 인덱스에서 해시 테이블 기반 인덱스는 다음과 같이 동작한다:

- (데이터 = 컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용
- 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현
- 시간복잡도: **O(1)** → 매우 빠른 검색 지원

하지만 해시 테이블은 DB 인덱스에서 **제한적으로만 사용**된다.  
그 이유는 해시가 **등호(=) 연산**에만 특화되었기 때문이다.

예시:
- `"나는"`으로 시작하는 모든 데이터를 검색하는 쿼리문 → **인덱스 혜택을 전혀 못 받음**
- 부등호 연산 (`>`, `<`) 이 자주 사용되는 DB 검색에는 적합하지 않음

따라서 실제 데이터베이스의 인덱스에서는 보통 **B+Tree** 가 사용된다.

---

## B+Tree

B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 **B-Tree를 개선**시킨 자료구조이다.

### 특징
- **리프노드(데이터 노드)**
    - 인덱스와 함께 데이터(Value)를 저장한다.
- **인덱스 노드(내부 노드)**
    - 데이터가 아닌 **인덱스(Key)** 만 가진다.
- **리프노드들은 LinkedList로 연결**되어 있어 순차 검색에 유리하다.
- 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 **부등호를 이용한 순차 검색**이 자주 발생한다.  
이를 위해 B+Tree는 리프노드를 LinkedList로 연결해 순차 검색을 용이하게 했다.

👉 단점: Best Case에서도 무조건 리프노드까지 가야 한다.  
👉 시간복잡도: **O(log₂n)**

하지만 이런 특성 덕분에 해시 테이블보다 **DB 인덱싱에 더 적합한 자료구조**가 되었다.

---

## InnoDB에서의 B+Tree 구조

InnoDB에서 사용되는 B+Tree는 일반적인 구조보다 더욱 복잡하다.

- 같은 레벨의 노드들: **Double Linked List** 로 연결
- 자식 노드들: **Single Linked List** 로 연결

---

## 참고
위에서는 인덱스에 대해 간단히 핵심만 다루고 있지만,  
**PK(Primary Key)와 인덱스(Index)** 에 대해서 자세히 아는 것도 매우 중요하다. 