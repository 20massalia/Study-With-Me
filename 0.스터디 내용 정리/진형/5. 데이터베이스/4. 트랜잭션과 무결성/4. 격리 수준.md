# 트랜잭션 격리 수준 단계

## 3.1 DBMS마다 다른 격리수준
트랜잭션 격리수준은 총 4단계로 **Uncommitted Read**, **Committed Read**, **Repeatable Read**, **Serializable** 로 구성된다.  
DBMS 마다 격리 수준에 대한 내용이 다를 수 있으니 보다 정확하게 알기 위해서는 공식 문서를 확인해야 한다.

- MySQL의 기본 격리수준은 **Repeatable Read** 이다.
- 필요에 따라 타 DBMS의 격리수준도 비교 분석할 수 있다.

---

## 3.2 Uncommitted Read (커밋되지 않은 읽기)
- 다른 트랜잭션에서 **커밋되지 않은 데이터**에 접근할 수 있게 하는 격리 수준이다.
- 가장 저수준의 격리수준이며, 일반적으로는 사용하지 않는다.

예시:
- 10번 트랜잭션이 `'박기영'`을 `'박경'`으로 UPDATE 후 **Commit하지 않았을 때**,
- 13번 트랜잭션에서 이를 읽으면 커밋되지 않은 데이터(`'박경'`)가 조회된다.

⚠️ 문제점:
- 10번 트랜잭션이 롤백되면, 13번 트랜잭션은 잘못된 데이터를 읽은 것이 되어 **데이터 부정합**이 발생한다.
- 이런 현상을 **Dirty Read(더티 읽기)**라고 한다.
- Oracle에서는 이 격리 수준을 아예 지원하지 않는다.

---

## 3.3 Committed Read (커밋된 읽기)
- 다른 트랜잭션에서 **커밋된 데이터만** 읽을 수 있는 격리 수준이다.
- MySQL을 제외한 대부분의 DBMS에서 기본 격리수준으로 사용한다.

예시:
- 10번 트랜잭션이 `'박기영'` → `'박경'` UPDATE 후 Commit하지 않았을 때,
- 13번 트랜잭션은 UPDATE 전 데이터 `'박기영'`을 조회한다.
- 따라서 Dirty Read 현상은 발생하지 않는다.

### Undo 영역
- 트랜잭션의 **Durability(지속성)**을 보장하기 위해 DB는 로그를 남긴다.
- 로그 종류:
    - **Redo Log** : 커밋된 트랜잭션 복구용
    - **Undo Log** : 롤백을 위해 변경 전 데이터 보관
- Undo Log는 메모리(Undo Buffer)에 저장된 후 특정 시점에 디스크에 기록된다.
- 따라서 Commit 되기 전 데이터를 Undo 영역에서 읽을 수 있다.

### Non Repeatable Read 문제
- Read Committed 수준에서는 **Non Repeatable Read(반복 불가능 읽기)**가 발생한다.
- 하나의 트랜잭션에서 동일한 SELECT를 두 번 실행했을 때, 다른 트랜잭션의 Commit 시점에 따라 결과가 달라진다.

---

## 3.4 Repeatable Read (반복 가능한 읽기)
- **Non Repeatable Read 문제를 해결**하는 격리 수준이다.
- Commit된 데이터만 읽되, **자신보다 낮은 트랜잭션 번호에서 Commit한 데이터**만 읽을 수 있다.
- 이를 가능하게 하는 기술: **MVCC(Multi Version Concurrency Control)**
    - Undo 로그와 트랜잭션 ID를 사용해 스냅샷처럼 데이터를 관리하여 동일한 SELECT 결과를 보장한다.

예시:
- 10번 트랜잭션은 자신보다 작은 트랜잭션에서 Commit한 데이터만 읽을 수 있으므로,
- 13번 트랜잭션에서 변경한 내용은 조회되지 않는다.
- 따라서 동일한 SELECT를 두 번 실행해도 같은 결과가 나온다.

### 오라클은 Repeatable Read를 지원하지 않는다
- 대신, **Exclusive Lock**을 사용하여 Non Repeatable Read 문제를 해결한다.

---

Reference
- https://tlatmsrud.tistory.com/118