# 절차형 프로그래밍

## 절차적(절차형) 프로그래밍(Procedural Programming)이란?

절차적 프로그래밍은 단순히 순차적인 명령 수행이 아니라 함수, 메소드, 루틴, 서브 루틴 등(이를 통틀어 ‘프로시저’라 함)을 이용한 프로그래밍 패러다임을 뜻하며, 넓은 의미에서 명령형 프로그래밍의 일종입니다.

### 절차지향? 객체지향의 반대?

절차적 프로그래밍을 객체지향 프로그래밍에 대조되는 것으로 생각하여 ‘절차지향 프로그래밍’이라고 지칭하기도 하나, 이는 잘못된 표현입니다.

절차적 프로그래밍과 객체지향 프로그래밍은 서로 반대되는 개념이 아닙니다.

두 개념은 **서로 다른 관점의 분류**로, **절차적 프로그래밍은 “코드를 어덯게 구조화하느냐”** 에 대한 방식이며 **객체지향 프로그래밍은 “데이터와 기능을 어떻게 묶느냐”** 에 대한 방식입니다.

즉, **절차형은 “함수를 중심으로 순서대로 처리하는 방식”** 이고 **객체지향은 “데이터와 기능을 객체로 묶는 설계 방식”** 입니다. 서로 배타적인 개념이 아니라, 구조화 수준이나 관점을 달리한 분류일 뿐입니다.

또한 객체지향 프로그램도 내부적으로는 명령어 단위의 절차 흐름을 따릅니다. **객체지향은 절차형을 대체하는 것이 아니라, 절차형 위에 더 나은 구조화 개념을 덧입힌 것**이죠.

### 함수형 프로그래밍인가?

현대 프로그래밍 언어에서 프로시저와 함수의 구분은 없어진 것이나 다름없기에 함수형 프로그래밍과 절차적 프로그래밍이 동등한 것이냐는 이야기가 있습니다.

하지만 **절차적 프로그래밍은 함수형 프로그래밍이 아닙니다**.

**절차적 프로그래밍은 함수를 “명령 순서를 묶는 도구”로 사용**합니다. 함수는 코드 재사용과 구조화 목적이며, 상태 변경과 부작용이 자유롭게 허용됩니다.

**함수형 프로그래밍은 함수를 “순수한 수학적 함수”로 사용**하며, 상태 변경을 지양하고 부작용 없는 순수 함수, 불변성, 고차 함수, 재귀 등을 중시합니다.

숫자 배열에서 짝수를 필터링하여 제곱한 후, 모두 더하는 예제를 통해 둘의 차이를 확인해보겠습니다.

**절차적 프로그래밍 방식 (명령형 + 상태 변경)**

```tsx
function processNumbers_procedural(numbers) {
  let result = 0;
  for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
      let square = numbers[i] * numbers[i];
      result += square;
    }
  }

  return result;
}

const numbers = [1, 2, 3, 4, 5];
console.log(processNumbers_procedural(numbers)); // 20
```

위 절차적 프로그래밍 방식에서는 상태 변수(`result`)를 선언하고 값을 변경하고 있습니다.

또한 명령어 중심(`for`, `if`, `+=`)이며 함수는 코드를 묶는 도구일 뿐 상태와 부작용을 포함합니다.

**함수형 프로그래밍 방식 (선언형 + 불변성 + 순수 함수)**

```tsx
function isEven(n: number): boolean {
  return n % 2 === 0;
}

function square(n: number): number {
  return n * n;
}

function sum(acc: number, n: number) {
  return acc + n;
}

const numbers = [1, 2, 3, 4, 5];
const result = numbers.filter(isEven).map(square).reduce(sum, 0);

console.log(result); // 20
```

위 함수형 프로그래밍에서 `numbers` 는 불변 데이터로 변경되지 않습니다.

모든 함수는 입력이 같으면 출력이 같고, 외부 상태를 변경하지 않는 순수 함수입니다.

고차 함수 `filter`, `map`, `reduce`로 데이터 흐름을 선언적으로 조작합니다.

상태 변경, 루프, 조건문의 사용이 없습니다.

이에 따라 **절차형은 “무엇을 어떻게 할 것인가(HOW)”에 초점**을 맞춘 명령 중심이며, **함수형은 “무엇을 할 것인가(WHAT)”에 초점**을 맞춘 계산 중심임을 확인할 수 있습니다.

## 절차적 프로그래밍의 장단점

### 장점

1. **간단하고 직관적인 흐름**: 프로그램이 위에서 아래로 순차적으로 실행되므로, 코드 흐름을 따라가기 쉽고 직관적입니다.
2. **성능 측면에서 효율적**: 객체 생성 등의 추상화 비용이 없기 때문에, 일반적으로 객체지향보다 실행 속도가 빠른 경우가 많습니다.
3. **명확한 순서 정의**: 모든 동작을 명령어 단위로 제어할 수 있어 논리적인 순서 구조를 정밀하게 설계할 수 있습니다.

### 단점

1. **유지보수의 어려움**: 프로그램이 커질수록 전역 변수나 공유 자원을 많이 사용하게 되어 버그 발생 가능성이 증가합니다. 또한 하나의 함수에 여러 역할이 섞여있기 쉬워 변경에 취약합니다.
2. **재사용성 낮음**: 데이터와 로직이 분리되어 있지 않아, 코드 재사용이 어렵고 중복 발생 가능성이 높습니다.
3. **확장성과 유연성 부족**: 새로운 기능이 추가되거나 요구사항이 바뀔 때, 기존 흐름을 많이 수정해야 합니다. 유연한 확장을 이한 설계 패턴 도입이 어렵습니다.

절차적 프로그래밍은 **작고 단순한 문제 해결에는 적합**하지만, 복잡한 시스템이나 장기적인 유지보수가 필요한 대규모 프로젝트에는 **객체지향적 또는 모듈화된 설계가 더 적합**합니다.

즉, 절차적 프로그래밍은 **단기 효율성**, 객체지향은 **장기 확장성과 유연성**을 위한 선택이라 볼 수 있습니다.

<br/>
<br/>

> 참고
>
> - https://kevinkim95-dev.tistory.com/2
> - https://velog.io/@phs880623/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%A0%88%EC%B0%A8%EC%A0%81%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
> - https://velog.io/@wngud4950/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DPP-vs-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8DOOP
> - https://wikidocs.net/227164
> - https://en.wikipedia.org/wiki/Procedural_programming
