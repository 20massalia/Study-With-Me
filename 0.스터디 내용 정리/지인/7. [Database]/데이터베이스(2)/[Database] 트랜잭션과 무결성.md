# 트랜잭션과 무결성

## 트랜잭션

트랜잭션은 **데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위**를 말합니다.

일반적으로 트랜잭션은 데이터베이스의 모든 변경을 뜻합니다.

데이터베이스 환경에서 트랜잭션의 목적은 두 가지입니다.

- **장애 복구와 일관성 유지**
  실패로부터 올바르게 복구하고, 시스템 장애가 발생하더라도 데이터베이스를 일관된 상태로 유지하게 하는 신뢰할 수 있는 작업 단위를 제공합니다.
- **동시성 격리 제공**
  데이터베이스에 동시에 접근하는 프로그램들 사이에 격리를 제공합니다.
  이 격리가 없으면 프로그램의 결과가 오류가 될 수 있습니다.

DBMS에서 트랜잭션은 때로 **여러 연산으로 구성되기도 하는 단일 논리 작업 단위**입니다.

데이터베이스에서 일관된 모드로 수행되는 모든 논리적 계산은 트랜잭션으로 간주됩니다.

예를 들어, 한 계좌에서 다른 계좌로 금액을 이체하는 경우 전체 트랜잭션은 이체 금액을 한 계좌에서 차감하고 동일한 금액을 다른 계좌에 가산하는 두 동작을 모두 포함해야 합니다.

우리가 트랜잭션을 알아야 하는 이유는 트랜잭션은 데이터베이스에서 데이터의 일관성과 무결성을 유지하는 데에 중요한 개념이기 때문입니다.

트랜잭션은 **ACID 속성을 준수함으로써 데이터의 일관성과 무결성을 유지**할 수 있습니다.

<br/>

## ACID

### Atomicity: 원자성

원자성은 **트랜잭션의 작업이 모두 수행되거나 전혀 수행되지 않도록 보장**하는 성질입니다.

여러 단계로 이루어진 트랜잭션이라도 모든 단계가 성공했을 때만 커밋되고, 하나라도 실패하면 전체가 롤백됩니다.

이를 통해 시스템 장애나 예기치 않은 중단이 발생해도 데이터 무결성과 일관성을 유지할 수 있습니다.

예시로 계좌이체는 ‘출금’과 ‘입금’ 두 작업으로 구성됩니다.

둘 중 하나라도 실패하면 전체 이체가 롤백되며, 출금만 되거나 입금만 되는 상황을 방지합니다.

- **커밋 (Commit)**
  트랜잭션의 모든 작업이 성공적으로 완료되었고, 데이터베이스의 상태가 일관성을 유지하는 경우에 트랜잭션을 커밋합니다.
  이 때, 트랜잭션이 완료되어 데이터베이스에 영구적으로 반영됩니다.
- **롤백 (Rollback)**
  트랜잭션의 어떤 이유로 인해 실패하거나 취소해야 할 때 트랜잭션을 이전 상태로 되돌리는 작업을 의미합니다.
  롤백을 수행하면 트랜잭션에 의한 변경 사항이 취소되고, 데이터베이스는 이전 상태로 되돌아갑니다.

<br/>

### Consistency: 일관성

일관성은 **데이터가 허용된 규칙과 제약을 위반하지 않도록 유지되는 성질**입니다.

트랜잭션 수행 전후로 데이터베이스는 정의된 제약(도메인, 참조 무결성, 유일성 등)과 비즈니스 규칙을 만족해야 하며, 변경은 항상 유효한 상태를 보장해야 합니다.

예를 들어, 트랜잭션에서 A계정에서 돈을 출금하고 B계정으로 입금하는 경우에는 A계정과 B계정의 잔액이 항상 일관된 상태를 유지해야 합니다.

<br/>

### Isolation: 격리성

격리성은 **동시에 실행되는 트랜잭션들이 서로 간섭하지 않도록 보장하는 특성**입니다.

즉, 각 트랜잭션은 독립적으로 실행된 것처럼 보이며, 다른 트랜잭션의 중간 결과(미커밋 변경)에 영향을 받지 않습니다.

격리성은 다음과 같은 이상 현상을 방지할 수 있기에 중요합니다.

- Dirty Read (더티 리드)
  커밋되지 않은 다른 트랜잭션의 변경 내용을 읽음 → 상대 트랜잭션이 롤백되면 읽은 값은 무효가 됨
- Non-repeatable Read (반복 불가능 읽기)
  같은 행을 두 번 읽을 때 값이 달라짐 → 사이에 다른 트랜잭션이 값을 변경
- Phantom Read (팬텀 리드)
  같은 조건으로 두 번 조회할 때 행의 집합이 달라짐 → 사이에 다른 트랜잭션이 행을 추가/삭제

---

- 격리 수준 (Isolation Level)
  여러 트랜잭션을 어느 정도까지 서로 격리할지 정하는 정책입니다.
  격리가 높을수록 일관성은 좋아지지만 동시성, 성능 비용이 커질 수 있습니다.

  1. Read Uncommitted

     다른 트랜잭션의 미커밋 변경도 읽기 가능

     Dirty/Non-repeatable/Phantom 모두 발생 가능

  2. Read Committed

     커밋된 데이터만 읽음

     Dirty Read는 방지하지만 Non-repeatable/Phantom은 가능

  3. Repeatable Read

     한 트랜잭션이 읽은 행의 값은 트랜잭션 종료까지 변하지 않음

     Non-repeatable Read 방지, Phantom은 여전히 가능 (엔진 구현에 따라 일부 완화될 수 있음)

  4. Serializable

     가장 강한 격리. 직렬 실행과 동등하게 동작

     Diry/Non-repeatable/Phantom 모두 방지

<br/>

### Durability: 지속성

지속성은 트랜잭션이 커밋된 뒤 그 결과가 영구히 보존되도록 보장하는 특성입니다.

커밋이 완료되면 변경사항은 비휘발성 저장장치에 의해 안전히 기록되어, 전원 차단/시스템 크래시 이후에도 복구 절차(redo/undo)를 통해 커밋 상태가 그대로 재현됩니다.

이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공합니다.

- **체크섬**: 페이지/블록 단위 데이터에 대해 계산한 짧은 무결성 코드(CRC, SHA 등) 를 함께 저장해 두고, 읽을 때 다시 계산해 손상 여부를 검증하는 기법
- **저널링**:
  - 파일시스템 저널링(FS Journaling): 파일시스템의 메타데이터(디렉터리, inode 등) 변경을 저널(로그) 에 먼저 기록한 뒤 실제 구조를 갱신하는 방식
  - 데이터베이스 WAL(Write-Ahead Log): 트랜잭션 변경을 로그에 먼저 기록·동기화하고, 그다음 데이터 페이지를 갱신하거나 체크포인트로 밀어냄

<br/>

## LOCK

### Lock의 개념

여러 커넥션(세션)이 같은 데이터(행/테이블 등)에 동시에 접근할 때 동시성 제어를 위해 걸어두는 “잠금”입니다.

핵심 목적은 트랜잭션 간 순차성 보장과 정합성 유지로, “화장실 칸에 들어간 사람이 안에서 문을 잠그는 것”에 비유할 수 있습니다.

작업 주체가 대상 자원 위에 직접 잠금을 확보합니다.

<br/>

### Lock의 종류

- 공유 락(Shared, S/Read Lock)
  읽기 용도, S ↔ S는 동시에 허용되지만 S가 잡힌 대상에는 X(쓰기)가 차단됩니다.
- 배타 락(Exclusive, X/Write Lock)
  쓰기 용도, X가 잡히면 S도 X도 모두 차단됩니다.

요약하면, S는 S만, X는 아무도 함께 들어올 수 없습니다.

<br/>

### Lock의 설정범위

DBMS는 락을 거는 범위를 여러 단계로 제공합니다.

- 데이터베이스 전체: 거의 사용하지 않으나, 점검/대규모 업데이트 수준에서 사용됩니다.
- 파일/페이지/블록/컬럼: 일부 엔진에서 제공하나 실무 빈도는 낮습니다.
- 테이블: 전체 테이블 단위의 락을 설정합니다. DDL 구문과 함께 사용되며 DDL Lock이라고도 합니다.
- 행(Row): 가장 흔한 DML 단위 Lock으로 특정 행만 잠급니다.

<br/>

### 블로킹(Blocking)

서로 호환되지 않는 락이 경합하여, 뒤늦게 들어온 트랜잭션이 대기 상태에 들어가는 현상입니다.

예를 들어,

- 대상에 S가 잡힌 상태에서 X를 시도 → 대기
- 대상에 X가 잡힌 상태에서 S/X를 시도 → 대기

대기는 앞선 트랜잭션이 커밋/롤백으로 락을 풀거나, 락 대기 시간 초과가 나기 전까지 지속됩니다.

이때 블로킹이 서로 맞물려 양쪽이 영원히 풀리지 않는 상태가 되면 데드락입니다.

<br/>

### 블로킹 해결 방안

개념적으로는 락 보유 시간과 충돌 확률을 낮추는 것이 핵심입니다.

- 트랜잭션을 짧고 작게 설계하여 불필요한 작업이 같은 트랜잭션에 묶이지 않도록 합니다.
- 동일 데이터에 대한 동시 갱신을 회피하여 설계 단계에서 경합 지접을 줄입니다.
  - 필요 시 비관적/낙관적 락을 적용할 수 있습니다.
- 불필요한 상향은 경합과 대기를 증가시키므로 격리 수준을 과도하게 올리지 않습니다.
- 대용량 작업은 피크 시간대를 회피하고 작업 단위를 분할하여 서비스 지연을 최소화합니다.
- 락 대기 시작 설정 및 모니터링으로 타임아웃을 통해 교착 대기 장기화를 방지합니다.
- 접근 순서를 통일하여 교차 접근을 피하면 데드락 가능성을 낮출 수 있습니다.

<br/>

## 격리 수준

### 개념

트랜잭션의 격리 수준(Isolation Level)은 여러 트랜잭션이 동시에 처리될 때, 한 트랜잭션이 다른 트랜잭션의 변경(또는 조회) 결과를 **얼마나 보지 않도록 할지**를 정하는 정책입니다.

격리를 강하게 할수록 정합성은 높아지지만 동시성이 떨어질 수 있고, 반대로 약하게 하면 처리량은 늘지만 부정합 가능성이 커집니다.

즉, **정확성 ↔ 성능** 사이의 트레이드오프를 조절하는 장치라고 볼 수 있습니다.

<br/>

### 격리 수준에서 문제가 되는 현상

동시에 실행될 때 대표적으로 세 가지 부정합이 발생할 수 있습니다.

**Dirty Read**(미커밋 데이터를 읽음), **Non-repeatable Read**(같은 행을 같은 트랜잭션에서 두 번 읽었는데 값이 달라짐), **Phantom Read**(같은 조건으로 두 번 조회할 때 행의 집합이 달라짐)입니다.

이 현상들을 얼마나 허용/차단하느냐가 각 격리 수준의 차이입니다.

<br/>

### 주요 격리 수준

### READ UNCOMMITTED — 가장 낮은 격리

커밋되지 않은 데이터 변경조차도 다른 트랜잭션에서 볼 수 있습니다.

따라서 미커밋 데이터를 읽는 Dirty Read가 발생합니다.

> **세션 A**
>
> ```sql
> SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
> START TRANSACTION;
> UPDATE accounts SET balance = balance + 100 WHERE id = 1; -- 아직 COMMIT 안 함
> ```
>
> **세션 B**
>
> ```sql
> SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
> START TRANSACTION;
> SELECT balance FROM accounts WHERE id = 1; -- A의 미커밋 값이 보임(Dirty Read)
> ```
>
> 이제 A가 `ROLLBACK` 하면, B가 봤던 값은 사라집니다.
>
> 이처럼 Dirty Read는 시스템 혼란을 유발하므로 실무에선 사실상 쓰지 않습니다.
>
> 일부 DBMS(예: Oracle)는 아예 지원하지 않기도 합니다.

---

<br/>

### READ COMMITTED — 커밋된 것만 본다

**커밋된 데이터만** 보므로 Dirty Read는 막지만, 같은 트랜잭션 안에서 두 번 읽을 때 사이에 다른 트랜잭션이 커밋하면 결과가 달라질 수 있어 **Non-repeatable Read**가 발생합니다.

> **세션 B**
>
> ```sql
> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
> START TRANSACTION;
> SELECT balance FROM accounts WHERE id = 1; -- 10,000 읽음
> ```
>
> **세션 A**
>
> ```sql
> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
> START TRANSACTION;
> UPDATE accounts SET balance = 20000 WHERE id = 1;
> COMMIT;
> ```
>
> **세션 B**
>
> ```sql
> SELECT balance FROM accounts WHERE id = 1; -- 이번엔 20,000 (Non-repeatable Read)
> COMMIT;
> ```

커밋된 것만 보겠다는 약속 때문에 Dirty Read는 없지만, 조회 결과의 일관된 반복성은 보장하지 않습니다.

다수의 DBMS 기본값이 이 수준이며, 금액 합계처럼 한 트랜잭션에서 **여러 번 읽고 계산**해야 하는 로직에는 주의가 필요합니다.

---

<br/>

### REPEATABLE READ — 같은 행은 반복해서 읽어도 같다

**한 트랜잭션 안에서 같은 행을 다시 읽어도 값이 변하지 않음**을 보장합니다.

보통 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)를 이용해 처음 읽을 때와 일관된 시점을 유지합니다.

그래서 Non-repeatable Read는 차단되지만, 행의 **삽입/삭제로 인해 집합이 바뀌는 Phantom Read**는 이론상 남습니다.

> #### 테이블과 초기 데이터
>
> ```sql
> CREATE TABLE accounts (
>   id INT PRIMARY KEY,
>   balance INT
> ) ENGINE=InnoDB;
>
> INSERT INTO accounts (id, balance) VALUES
> (1, 10000), (2, 8000), (3, 12000);
> -- 초기 상태: balance >= 10000 만족 행은 (id=1, id=3) 두 개
> ```
>
> #### 세션 B (독자): 스냅샷으로 첫 조회
>
> ```sql
> -- 세션 B
> SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
> START TRANSACTION;
>
> -- 스냅샷 일관성으로 읽음(잠금 없음: FOR UPDATE/LIMIT 없음)
> SELECT id, balance FROM accounts WHERE balance >= 10000;
> -- 결과: (1, 10000), (3, 12000)  -- 2행
> ```
>
> #### 세션 A (동시 트랜잭션): 조건을 만족하는 새 행 삽입 후 커밋
>
> ```sql
> -- 세션 A
> SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
> START TRANSACTION;
>
> INSERT INTO accounts (id, balance) VALUES (4, 15000);
> COMMIT;
> -- 이제 테이블엔 balance >= 10000 만족 행이 3개가 됨: id 1,3,4
> ```
>
> #### 세션 B: 두 번째 조회를 잠금 읽기로 변경
>
> ```sql
> -- 세션 B (같은 트랜잭션 안)
> -- 이번에는 '잠금 있는 읽기'로 전환
> SELECT id, balance FROM accounts
> WHERE balance >= 10000
> FOR UPDATE;
> -- 결과: (1, 10000), (3, 12000), (4, 15000)  -- "새로운 행(id=4)"이 보임 (팬텀)
> COMMIT;
> ```
>
> - 첫 번째 SELECT는 **스냅샷 읽기**였기 때문에 트랜잭션 시작 시점의 일관된 결과(2행)만 봅니다.
> - 두 번째는 `FOR UPDATE`로 **잠금 읽기**가 되었고, InnoDB는 이때 **현재 커밋된 레코드**를 기준으로 읽으면서 범위를 잠급니다.
>
> - 그 결과, 세션 A가 중간에 커밋한 **신규 행(id=4)** 이 **추가로 나타나며**(= 집합이 달라짐) **팬텀**이 관찰됩니다.

---

<br/>

### SERIALIZABLE — 직렬 실행과 동일

가장 엄격한 격리 수준으로, 논리적으로 모든 트랜잭션이 **순차 실행된 것과 동일**한 결과를 보장합니다.

여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로 어떠한 데이터 부정합도 발생하지 않습니다.

하지만 트랜잭션이 순차적으로 처리됟어야 하므로 동시성 비용이 큽니다.

<br/>

## 교착 상태

### 교착상태란?

교착상태는 두 개 이상의 트랜잭션이 서로 보유한 자원을 기다리며 무한 대기에 빠지는 상황을 말합니다.

다중 사용자 환경에서 동시에 실행되는 트랜잭션이 많을수록 발생 가능성이 높습니다.

<br/>

### 발생 조건

교착 상태가 일어나려면 보통 다음 네 가지(코프만의 4조건)가 동시에 성립합니다.

네 가지 중 하나라도 깨지면 교착상태는 발생하지 않습니다.

- **상호배제**: 자원을 한 번에 한 트랜잭션만 사용
- **점유대기**: 일부 자원을 가진 채 다른 자원을 대기
- **비선점**: 이미 할당된 자원을 강제로 빼앗지 않음
- **순환대기**: 트랜잭션들이 원형으로 서로의 자원을 대기

```sql
-- 세션 A
START TRANSACTION;
UPDATE orders SET status='SHIPPING' WHERE id=1;  -- id=1에 X락
UPDATE orders SET status='SHIPPING' WHERE id=2;  -- 여기서 대기(세션 B가 보유)

-- 세션 B
START TRANSACTION;
UPDATE orders SET status='SHIPPING' WHERE id=2;  -- id=2에 X락
UPDATE orders SET status='SHIPPING' WHERE id=1;  -- 여기서 대기(세션 A가 보유)
-- A는 B의 락을, B는 A의 락을 기다리며 순환대기 → 교착상태
```

위와 같이 여러 행을 갱신할 때 서로 다른 트랜잭션이 서로가 먼저 잠근 행을 뒤에서 잠그려 할 때 대표적으로 발생합니다.

<br/>

### 대응 전략

1. 예방 (Prevention)
   - 필요 자원을 시작 시 일괄 잠금
     트랜잭션 시작 전에 필요한 모든 잠금을 획득하고, 하나라도 못 얻으면 즉시 해제/재시도합니다.
     다만 병행성이 크게 떨어지고 기아(starvation) 현상의 위험이 있습니다.
     완화책으로 FCFS 큐를 사용할 수 있습니다.
   - 락 대기 시간 제한 (LOCK_TIMEOUT)
     일정 시간을 넘기면 대기를 중단합니다. 근본 원인 제거는 아니지만 장기 교착을 막는 데 유효합니다.
2. 회피 (Avoidance)
   - 타임스탬프 기반 정책으로 순환대기를 원천 차단합니다.
     - Wait-Die: 오래된 트랜잭션(선행 트랜잭션)은 기다리고, 새로운 트랜잭션(후행 트랜잭션)은 롤백 후 재시도합니다. (비선점)
     - Wound-Wait: 선행이 오면 후행을 선점(롤백)하고, 후행이 오면 대기시킵니다. (선점)
3. 감지 / 해결
   - 자동 교착 감지
     DBMS가 대기 그래프(wait-for-graph)를 분석해 순환을 발견하면, 진행도가 낮은 트랜잭션을 희생(victim)으로 선정해 롤백시켜 교착을 해소합니다.
   - 타임아웃 기반 종료
     일정 시간 내 진행이 없으면 트랜잭션을 종료합니다.
   - 로그/모니터링
     교착 이벤트와 관련 잠금 정보를 로그로 남겨 진단할 수 있습니다.
4. 빈도 낮추기
   - 자주 커밋해 락 보유 시간을 줄입니다.
   - 테이블/레코드 접근 순서를 통일해 순환대기 가능성을 낮춥니다.
   - 필요하지 않은 `SELECT … FOR UPDATE` 남용 자제 (읽기 잠금 경합 최소화)
   - 여러 행을 무작위 순서로 갱신해야 한다면 최악의 경우 테이블 락으로 직렬화해 교착 대신 동시성 일부를 포기할 수도 있습니다.

<br/>
<br/>

> 참고
>
> - https://hulrud.tistory.com/100
> - https://hotechstory.tistory.com/67
> - https://moosongsong.github.io/junior-be-interview/05_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/30_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC%20%EB%AC%B4%EA%B2%B0%EC%84%B1.html#%E1%84%80%E1%85%A7%E1%86%A8%E1%84%85%E1%85%B5%E1%84%89%E1%85%A5%E1%86%BC-isolation
> - https://en.wikipedia.org/wiki/Database_transaction
> - https://sabarada.tistory.com/121
> - https://ksh-coding.tistory.com/121
> - https://mangkyu.tistory.com/299
> - https://tlatmsrud.tistory.com/118
> - https://cladren123.tistory.com/264
> - https://velog.io/@ahngj96/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EB%93%9C%EB%9D%BD
