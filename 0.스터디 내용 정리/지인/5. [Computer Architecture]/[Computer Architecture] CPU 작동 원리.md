# CPU 작동 원리

## CPU의 구성 요소

앞서 CPU는 컴퓨터의 두뇌로 산술 논리 연산을 수행하는 ALU, 명령어의 순서와 수행을 제어하는 제어 장치, 그리고 중간 결과와 작업 상태를 저장하는 레지스터가 있다고 했습니다.

이에 대해 더욱 자세히 살펴보도록 하겠습니다.

### 1. ALU (산술 논리 장치)

ALU는 덧셈, 뺄셈, 곱셈, 나눗셈 등의 산술 연산뿐만 아니라 AND, OR, NOT, XOR 등 비트 단위의 논리 연산을 수행합니다.

1. **입력**
   - 두 개 이상의 피연산자를 레지스터에서 받아옵니다.
   - 제어 장치로부터 ‘어떤 연산을 수행할지’에 대한 신호를 전달받습니다.
2. **연산 처리**
   - 피연산자와 제어 신호에 따라 해당 산술·논리 연산을 수행합니다.
   - 현대 CPU는 더 빠른 처리를 위해 덧셈 전용 회로, 부동소수점 연산 유닛(FPU)을 별도로 두기도 합니다.
3. **출력 및 플래그 설정**
   - 연산 결과를 결과 레지스터에 저장하거나, 필요 시 메모리로 전송합니다.
   - **플래그 레지스터**에 상태 정보를 기록하여 이후 분기나 조건 실행에 활용합니다.

<br/>

**주요 플래그의 의미**

| 플래그 종류                            | 의미                                                                     |
| -------------------------------------- | ------------------------------------------------------------------------ |
| 부호 플래그(Sign)                      | 연산 결과의 최상위 비트가 1(음수)인지 0(양수)인지를 나타냅니다.          |
| 제로 플래그(Zero)                      | 연산 결과가 0이면 1, 그렇지 않으면 0으로 설정됩니다.                     |
| 캐리 플래그(Carry)                     | 덧셈에서 올림이 발생하거나 뺄셈에서 빌림이 발생했을 때 1로 설정됩니다.   |
| 오버플로우 플래그(Overflow)            | 부호 있는 연산에서 결과가 표현 가능한 범위를 벗어났을 때 1로 설정됩니다. |
| 인터럽트 가능 플래그(Interrupt Enable) | 외부 인터럽트를 허용할지 여부를 나타냅니다.                              |
| 슈퍼바이저 플래그(Supervisor/User)     | 현재 실행 모드(커널 모드 또는 사용자 모드)를 구분합니다.                 |

---

### 2. 제어 장치 (Control Unit)

제어 장치는 CPU 내부와 주변 장치에 필요한 제어 신호를 생성·분배하여, 전체 시스템이 올바른 순서와 타이밍으로 작동하도록 조율합니다.

### 2.1. 입력 신호

- **클럭 신호(Clock)**
  일정한 주기로 펄스를 생성하여 각 처리 단계(페치→디코드→실행 등)의 타이밍을 맞춥니다.
- **명령어 레지스터(IR)의 명령어**
  메모리에서 가져온 현재 실행할 명령어의 비트 패턴을 해독합니다.
- **플래그 레지스터의 상태**
  이전 연산 결과에 따라 분기 여부 등을 결정할 때 참고합니다.
- **제어 버스(Control Bus)의 외부 신호**
  입출력 장치나 메모리 컨트롤러 등 외부 장치로부터의 요청(인터럽트 등)을 수신합니다.

### 2.2. 제어 신호 생성

1. **명령어 해독(Decode)**

   IR에 저장된 명령어의 연산 코드(opcode)를 분석하여, 어떤 연산·동작을 수행할지 결정합니다.

2. **신호 분배(Distribute Control Signals)**
   - **내부 제어 신호**: ALU, 레지스터, 셀렉터 등에 필요한 제어선을 활성화합니다.
   - **외부 제어 신호**: 메모리 읽기/쓰기, 입출력 장치와의 데이터 전송 등을 지시합니다.
3. **상태에 따른 분기 제어**

   플래그 레지스터의 값을 참조하여, 분기(branch)나 점프(jump) 명령을 올바르게 수행합니다.

이 과정을 통해 CPU는 **페치(Fetch) → 디코드(Decode) → 실행(Execute) → 결과 저장(Write-back)** 의 명령어 처리 사이클을 반복합니다.

---

### **3. 레지스터 (Register)**

레지스터는 CPU 내부에 매우 빠른 속도로 접근 가능한 소형 기억 장치로, 연산 중간 결과나 제어 정보를 저장합니다.

주요 레지스터는 다음과 같습니다.

1. **프로그램 카운터(Program Counter, PC)**
   - 다음에 실행할 명령어의 메모리 주소를 저장합니다.
   - 명령어가 실행될 때마다 자동으로 증가하며, 분기나 호출 명령일 경우 해당 주소로 갱신됩니다.
2. **명령어 레지스터(Instruction Register, IR)**
   - 현재 디코드 중인 명령어를 저장합니다.
   - 이곳의 데이터를 바탕으로 제어 장치가 어떤 동작을 수행할지 결정합니다.
3. **메모리 주소 레지스터(Memory Address Register, MAR)**
   - 메모리 접근 시 사용할 주소를 저장합니다.
   - 읽기·쓰기할 메모리 셀의 위치를 가리킵니다.
4. **메모리 버퍼 레지스터(Memory Buffer Register, MBR)**
   - 메모리로부터 읽어들인 데이터나 메모리에 기록할 데이터를 일시 저장합니다.
5. **범용 레지스터(General-Purpose Registers)**
   - 산술·논리 연산의 피연산자 및 결과 저장, 임시 데이터 보관 등에 사용됩니다.
   - 예: x86 계열의 AX, BX, CX, DX; ARM 계열의 R0–R15 등
6. **플래그 레지스터(Flag Register)**
   - ALU 연산 결과의 상태(부호, 제로, 캐리, 오버플로우 등)와 CPU 모드를 나타냅니다.
   - 분기나 인터럽트 처리 시 중요한 판단 근거가 됩니다.
7. **스택 포인터(Stack Pointer, SP) 및 베이스 포인터(Base Pointer, BP)**
   - 호출·복귀, 지역 변수 관리 등 스택 기반 메모리 관리를 위해 사용합니다.

<br/>
<br/>

> 참고
>
> - https://maloveforme.tistory.com/152
