# 싱글톤 패턴 (Singleton Pattern)

어떤 클래스가 최초 단 한 번만 메모리를 할당(static)하고, 그 메모리에 인스턴스를 생성하여 전역에서 공유하는 디자인 패턴입니다.

싱글톤 패턴의 주요 목적은 다음과 같습니다.

- **단일 객체 생성**: 클래스에 대해 오직 하나의 인스턴스만 생성
- **전역 객체 제공**: 애플리케이션 어디서나 동일한 인스턴스에 접근
- **공유 리소스 동시 접근 제어**: 여러 객체가 같은 리소스를 안전하게 공유

<br/>

# 구현 구조

```tsx
class Singleton {
  // 클래스 단위로 단 하나만 존재하는 정적 필드, 클래스 로딩 시 단 한 번만 메모리에 할당
  // 프로그램 실행 중 오직 하나의 인스턴스만 보유
  private static instance: Singleton;

  // 외부에서 new 연산자로 생성 불가 -> 인스턴스 생성을 통제
  private constructor() {}

  // 인스턴스가 없으면 생성, 이미 있으면 기존 인스턴스 반환
  public static getInstance(): Singleton {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}
```

## `static` 키워드의 의미

- **정적 멤버**: 클래스 인스턴스가 아니라 클래스 자체에 속함
- **공유 메모리**: 모든 코드가 같은 `static` 필드를 참조
- **객체 생성 없이 접근**: `Singleton.getInstance()` 또는 `Example.value`처럼 사용

```tsx
class Example {
  static value = 42;
}
console.log(Example.value); // 객체 생성 없이 접근 가능
```

## 언제, 왜 사용하나?

- **메모리 절약**: 객체를 매번 생성하지 않고 한 번만 생성
- **전역 상태 공유**: 애플리케이션 전반에서 동일한 인스턴스와 데이터를 공유
- **인스턴스 유일 보장**: 절대 두 개 이상 생성되지 않아야 하는 리소스 관리

## 장점

- **메모리 낭비 방지**: 반복 생성 방지
- **편리한 전역 접근**: 어디서든 같은 객체 참조
- **상호 연관 객체 간 데이터 공유**: 일관된 상태 유지

## 단점 및 주의사항

1. **높은 결합도**
   - 싱글톤이 너무 많은 책임을 가질 경우 개방-폐쇄 원칙 위반
   - 유지보수 및 단위 테스트가 어려워질 수 있음
2. **동시성 문제**
   - 멀티스레드 환경에서 동기화 처리가 없으면 복수 인스턴스 생성 위험
3. **과도한 전역 상태**
   - 전역 객체 남발 시 시스템 복잡도 증가
   - 테스트 격리(Test Isolation) 어려움

<br/>

> **결론**:
>
> 싱글톤이 꼭 필요한 경우에만 적용하고, 책임을 최소화하며 동기화와 테스트 설계를 함께 고려해야 합니다.
