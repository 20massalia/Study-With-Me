# 공유 자원과 임계 영역

## 공유 자원 (Shared Resource)

공유 자원은 **여러 프로세스가 공동으로 사용하는 변수, 메모리, 파일, 데이터 등의 자원**을 의미합니다.

여러 프로세스가 동시에 이용하기 때문에 **누가 언제 데이터를 읽거나 쓰느냐에 따라 결과가 달라질 수 있습니다.**

이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 **경쟁 상태(race condition)**라고 합니다.

<br/>

## 임계 구역 (Critical Section)

임계 구역은 **공유 자원의 접근 순서에 따라 실행 결과가 달라질 수 있는 프로그램의 영역**을 의미합니다.

전역 변수뿐만 아니라 하드웨어 자원을 사용할 때도 적용되는 개념으로, 예를 들어 프린터 1대를 여러 프로세스가 사용하는 경우 해당 프린터 사용이 임계 구역이 될 수 있습니다.

- 프로세스 A: 50페이지 보고서를 출력하려고 함
- 프로세스 B: 계약서 2페이지를 출력하려고 함

만약 임계 구역 제어 없이 두 프로세스가 동시에 프린터를 사용하면 출력물이 섞여 나와 올바른 결과를 얻을 수 없습니다.

이는 곧 데이터의 일관성과 신뢰성이 깨짐을 의미합니다.

따라서 임계 구역은 프로세스들이 동시에 작업해서는 안 되며, 다음과 같은 3가지 해결 조건을 충족해야 합니다.

<br/>

## 임계 구역 해결 조건

1. **상호 배제 (Mutual Exclusion)**

   한 프로세스가 임계 구역에 들어가면 다른 프로세스는 임계 구역에 들어갈 수 없다.

   → 한 번에 한 프로세스만 프린터를 사용할 수 있도록 락(lock)을 건다.

2. **한정 대기 (Bounded Waiting)**

   어떤 프로세스도 무한히 대기해서는 안 된다.

   즉, 임계 구역에 진입할 다음 프로세스는 유한한 시간 내에 결정되어야 하며, 특정 프로세스가 계속해서 임계 구역에 진입하지 못하는 상황이 발생해서는 안 된다.

   → 예를 들어 프린트 대기열을 큐로 관리하여, 먼저 요청한 프로세스가 출력 기회를 먼저 가지도록 한다. 해당 프로세스가 끝나면 대기 중인 프로세스가 출력 기회를 얻는다.

3. **진행의 융통성 (Progress Flexibility)**

   한 프로세스가 불필요하게 다른 프로세스의 진행을 방해해서는 안 된다.

   → 프린터가 비어있는데도 어떤 프로세스도 사용하지 못하는 상황(교착상태)은 없어야 한다.

<br/>

## 임계 구역 해결 방법

1. **뮤텍스 (Mutex)**
   - 뮤텍스는 Mutual Exclusion의 준말로, 한 번에 하나의 프로세스나 스레드만 임계 구역에 진입할 수 있도록 보장하는 동기화 도구입니다.
   - 락(lock)과 동일한 개념으로 사용되며, 커널 수준에서 관리되어 스레드가 대기할 경우 대기 상태로 전환(sleep)되어 CPU 낭비 없이 대기합니다.
   - 프린터 공유를 위해 하나의 뮤텍스를 생성하고
     - lock(mutex) → 프린터 임계 구역 진입
     - 출력이 끝나면 unlock(mutex) → 프린터 해제
     이를 통해 한 프로세스가 프린터를 사용 중일 떄 다른 프로세스는 대기 상태가 되어 출력물의 혼합을 방지할 수 있습니다.
2. **피터슨 알고리즘 (Peterson’s Algorithm)**

   - 두 프로세스 간 상호 배제, 진행성, 한정 대기를 보장하는 소프트웨어 방식의 동기화 알고리즘입니다.
   - `flag` : 프로세스의 진입 의사 표시
   - `turn` : 누가 먼저 임계 구역에 들어갈지 결정하는 순서 지정자

   ```java
   // 공유 변수
   boolean lock1 = false; // 프로세스 1이 임계 구역에 들어가고 싶다는 의사 표시
   boolean lock2 = false; // 프로세스 2가 임계 구역에 들어가고 싶다는 의사 표시
   int turn = 1;

   // 프로세스 1
   lock1 = true;          // 프로세스 1: 나 임계 구역 들어가고 싶다
   turn = 2;              // 양보 우선권을 프로세스 2에게 준다
   while(lock2 == true && turn == 2); // 바쁜 대기
   /*** 임계구역 ***/       // 프로세스 1의 임계 구역 진입
   lock1 = false;         // 프로세스1: 임계구역 사용 종료, 의사 해제

   // 프로세스 2
   lock2 = true;
   turn = 1;
   while(lock1 == true && turn == 1);
   /*** 임계구역 ***/
   lock2 = false;
   ```

3. **데커 알고리즘 (Dekker’s Algorithm)**

   - 최초로 고안된 상호 배제 알고리즘으로, 바쁜 대기 방식이며 flag와 turn 개념을 활용합니다.
     Peterson보다 구조가 복잡하고 교착 상태(deadlock), 기아(starvation) 방지까지 고려됩니다.

   ```java
   // 공유 변수
   boolean lock1 = false; // 프로세스 1이 임계 구역에 들어가고 싶다는 의사 표시
   boolean lock2 = false; // 프로세스 2가 임계 구역에 들어가고 싶다는 의사 표시
   int turn = 1;

   // 프로세스 1
   lock1 = true;          // 프로세스 1: 나 임계 구역 들어가고 싶다
   while(lock2 == true) { // 상대(프로세스 2)도 임계구역을 원한다면
   	if(turn == 2) {      // 지금이 프로세스 2 차례라면 프로세스 1은 양보
   		lock1 = false;     // 프로세스 1의 양보: 프로세스 2에게 우선권을 줌
   		while(turn == 2);  // 차례가 프로세스 1에게 올 때까지 바쁜 대기
   		lock1 = true;      // 프로세스 1이 다시 진입 의사 표시
   	}
   }
   /*** 임계구역 ***/       // 프로세스 1의 임계 구역 진입
   turn = 2;              // 임계구역 종료: 차례를 프로세스 2에게 넘김
   lock1 = false;         // 프로세스1: 임계구역 사용 종료, 의사 해제

   // 프로세스 2
   lock2 = true;
   while(lock1 == true) {
   	if(turn == 1) {
   		lock2 = false;
   		while(turn == 1);
   		lock2 = true;
   	}
   }
   /*** 임계구역 ***/
   turn = 1;
   lock2 = false;
   ```

4. **세마포어 (Semaphore)**
   - 세마포어는 음이 아닌 정수값 기반의 자원 카운터로, `P()` (획득, wait)와 `V()` (해제, signal) 함수를 통해 자원 접근과 스레드 동기화를 조절합니다.
   - wakeup 신호를 사용하기 때문에 바쁜 대기를 하지 않아도 됩니다.
   - 구분
     - **카운팅 세마포어**: 자원 개수를 표현 → 여러 동시 접근 허용
     - **바이너리 세마포어 (0 또는 1)**: 뮤텍스처럼 동작
   - `semaphore printer = 1;`
     - 출력 요청 시 `P(printer)`: 잠금을 수행하는 코드 → 카운터 1에서 0 → 진입 허용
     - 출력 종료 시 `V(printer)`: 잠금 해제와 동기화를 같이 수행하는 코드 → 카운터 0에서 1 → 대기 중인 프로세스 하나를 깨움(wakeup) → 다음 출력 실행
5. **모니터**
   - 모니터는 뮤텍스와 하나 이상의 조건 변수(condition variable)를 포함하는 고수준의 동기화 기법입니다.
     내부 연산은 자동으로 상호 배제를 보장하고, 조건에 따라 다중 스레드를 대기 및 신호할 수 있습니다.
     모니터는 요청받은 작업을 모니터 큐에 저장한 수 순서대로 처리하고, 결과만 해당 프로세스에 알려줍니다.
   - 기능
     - `wait(cv)`: 조건이 충족될 때까지 기다리고, 그 사이 락을 해제
     - `signal(cv)`: 조건이 만족된 스레드를 꺠움 → 락 반환 후 재진입
   - 모니터 내부에 `print()` 메서드를 구현
     - 프린터가 사용 중일 떄 `nonavailable.wait()` 호출
     - 출력이 끝나면 `nonavailable.signal()` 호출 → 대기 중인 스레드에게 통보
   - 즉, 개발자가 락과 대기 관리에 대해 직접 다루지 않아도, 모니터 안의 로직만으로 안정적인 동기화가 가능합니다.

<br/>

**※ 바쁜 대기(busy-waiting)란?**

- OS에서는 원하는 자원을 얻기 위해 기다리는 것이 아니라 **권한을 얻을 때까지 확인하는 것**을 의미합니다.
- CPU의 자원을 쓸데 없이 낭비하기 때문에 좋지 않은 쓰레드 동기화 방식입니다.

<br/>
<br/>

> 참고
>
> - https://velog.io/@jsb100800/CS-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD
> - https://velog.io/@suyeonme/OS-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD
> - https://goodbyeanma.tistory.com/211
> - https://daily-progress.tistory.com/65
> - https://blog.system32.kr/80
