# 교착 상태

교착 상태로 번역되는 데드락(deadlock)은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태입니다.

예를 들어 하나의 사다리가 있고, 두 명의 사람이 각각 사다리의 위쪽과 아래쪽에 있다고 가정합시다.

이때 아래에 있는 사람은 위로 올라가려 하고, 위에 있는 사람은 아래로 내려오려고 한다면 두 사람은 서로 상대방이 비켜줄 때까지 하염없이 기다리게 됩니다.

결과적으로 아무도 사다리를 내려오거나 올라가지 못하게 되듯이, 데드락에 빠진 프로세스들은 그 누구도 빠져나오지 못하고 다른 작업을 진행할 수 없게 됩니다.

<br/>

## 교착 상태의 조건

교착 상태가 일어나려면 다음과 같은 네 가지 필요 조건을 충족시켜야 합니다.

1. **상호배제 (Mutual exclusion)**

   **프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.**

   즉, 한 프로세스가 사용 중인 자원을 다른 프로세스가 획득하지 못한다.

2. **점유대기 (Hold and Wait)**

   **프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.**

   예를 들면 Zoom, 카메라 앱, 마이크 앱이 카메라와 마이크라는 자원을 사용하려 할 때, 카메라 앱이 이미 카메라를 사용하고 있으면 Zoom은 마이크를 잡고 있는 상태로 카메라를 기다리게 되고, 이 때문에 녹음기 앱은 마이크를 못 쓰게 된다.

3. **비선점 (Non preemption)**

   **프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.**

   내가 얻고자 하는 자원을 이용하는 다른 프로세스의 작업이 끝나기만을 기다려야 한다.

4. **원형대기 (Circular wait)**

   **각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.**

   가장 유명한 예시로 식사하는 철학자 문제가 있다.

   <p align="center">
     <img src="../../image/교착상태.png" alt="교착상태" width="30%">
   </p>

   - 다섯 명의 철학자가 하나의 원탁에 앉아 식사를 한다.
   - 각각의 철학자들 사이에는 포크가 하나씩 있고, 양손에 포크를 하나씩 잡고 사용해 먹어야만 한다.
   - 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다.
   - 따라서 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하는 중이어야 한다.
   - 또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다.
   - 마지막으로, 각 철학자는 서로가 배가 고픈지 단지 생각하는 중인지 알 수 없다고 가정한다.

   이때 모두가 왼쪽 포크부터 집어드는 알고리즘을 실행한다고 하면, 5명의 철학자 모두 왼쪽 포크를 들고 오른쪽 포크를 얻기 위해 무한정 기다리는 교착 상태에 빠지게 된다.

<br/>

## 교착 상태의 해결 방법

운영체제는 교착 상태가 발생하지 않도록 **예방(Prevention)** 을 적용할 수 있고, 발생 위험이 있을 때는 **회피(Avoidance)** 를 통해 안전한 상태만 유지하도록 할 수 있습니다.

또한 교착 상태가 **탐지(Detection)** 되면 적절한 **회복(Recovery)** 절차로 시스템을 정상화합니다.

여기서 교착 상태는 상호배제, 점유대기, 비선점, 원형대기의 네 조건이 동시에 성립할 때 발생합니다.

1. **예방 (Prevention)**

   예방은 교착의 네 조건 중 하나 이상이 **애초에 성립하지 않도록** 제약을 두는 접근입니다.

   - **상호배제 제거**: 두 개 이상의 프로세스가 공유가능한 자원을 사용할 때 발생하는 것이므로 공유 불가능한, 즉 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있습니다.
     그러나 현실적으로 모든 자원의 상호배제를 제거하기에는 무리가 있습니다.

   - **점유대기 제거**: 마치 식사하는 철학자 문제에서 철학자들에게 한 손에 포크를 들고, 다른 포크를 기다리지 못하게 금지하는 것과 같습니다.
     프로세스가 실행되기 전에 필요한 모든 자원을 한 번에 요청하게 하거나, 자원을 보유한 상태에서는 추가 요청을 금지하는 정책을 의미합니다.
     다만 자원 활용도가 떨어지고, 실제로 필요한 시점보다 오래 자원을 점유하게 되어 효율성이 저하됩니다.
   - **비선점 제거**: 프로세스가 어떤 자원을 요청했는데 즉시 할당받지 못하면, 그 프로세스가 보유 중인 자원을 선점(반납)하게 만드는 규칙을 두는 것입니다.
     선점 모드가 되면 자원을 사용 중인 프로세스의 자원을 빼앗아서 사용이 가능합니다.
     상황에 따라 비선점 모드 또는 선점 모드가 장단점을 가질 수 있기에, 다소 범용성이 떨어집니다.
   - **원형대기 제거**: 자원 유형에 총순서(전체 순서)를 부여하고 모든 프로세스가 그 순서에 따라 자원을 획득·반납하도록 강제하는 것입니다.
   - 구현은 단순하지만 자원 분류와 순서 설계가 까다롭고, 특정 자원의 이용률이 떨어질 수 있습니다.

2. **회피 (Avoidance)**

   회피는 시스템이 안전 상태(safe state)만 유지하도록 자원 할당을 결정하는 접근이며, 프로세스별 **최대 자원 수요에 대한 정보**가 필요합니다.

   대표적으로 은행원 알고리즘이 여러 인스턴스 자원에 대해 안전 여부를 검사하여, 요청을 허용해도 모든 프로세스가 결국 완료 가능한 시퀀스가 존재할 때만 할당합니다.

   단일 인스턴스 자원 상황에서는 청구 간선이 포함된 자원 할당 그래프(Resource Allocation Graph)로 원형 형성 가능성을 사전에 차단할 수 있습니다.

   회피는 교착 자체를 막지만, 정보 요구와 검사 오버헤드 때문에 처리량이 감소하거나 요청이 지연될 수 있습니다.

3. **탐지(Detection) 와 회복(Recovery)**

   탐지/회복은 교착을 **허용**하되, 주기적으로 상태를 점검해 교착을 발견하면 그때 **정리**하는 접근입니다.

   단일 인스턴스 자원에서는 대기 그래프(Wait-for Graph)의 순환 검출로, 다중 인스턴스 자원에서는 은행원 계열의 검사를 응용한 탐지 알고리즘으로 교착 여부를 확인합니다.

   탐지 주기를 짧게 하면 반응성은 좋아지지만 오버헤드가 커지고, 길게 하면 교착 지속 시간이 길어질 수 있습니다.

   회복 방법으로는 **자원 선점**과 **프로세스 종료**가 있습니다.

   자원 선점은 교착에 연루된 프로세스에서 자원을 회수하거나 상태를 **롤백**해 다시 시도하게 만드는 방식으로, 선점이 가능한 자원과 체크포인트가 전제되어야 데이터 일관성을 지킬 수 있습니다.

   프로세스 종료는 연루된 프로세스를 모두 중단하거나, 피해 비용이 가장 낮은 희생양을 선택해 순차적으로 중단하는 방식이 있습니다.

   이때 작업 손실, 기아(starvation) 위험, 우선순위 역전 등을 고려해 공정한 **희생양 선정 기준**과 재시도 정책을 함께 설계하는 것이 바람직합니다.

<br/>
<br/>

> 참고
>
> - https://haon.blog/cs/os/deadlock/
> - https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C
> - 사진 출처: https://namu.wiki/w/%EB%8D%B0%EB%93%9C%EB%9D%BD
