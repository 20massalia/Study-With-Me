# 선언형과 함수형 프로그래밍

## 선언형 프로그래밍이란?

**선언형 프로그래밍**은 ‘**WHAT**’에 초점을 맞춘다고들 많이 표현합니다. 이는 ‘HOW’에 초점을 맞춘 명령형 프로그래밍과 대비되죠. 위키피디아에선 선언형 프로그래밍을 두 가지 의미로 설명하고 있습니다.

1. 한 정의에 따르면, 프로그램이 어떤 방법으로(HOW) 해야 하는지를 나타내기보다 **무엇(WHAT)과 같은지**를 설명하는 경우에 “선언형”이라고 한다.

예를 들어, 친구에게 우리 집까지 오는 방법을 설명해봅시다.

명령형(HOW): 주차장 북쪽 출구로 나와서 좌회전 해. 직진하다가 이마트를 마주치면 사거리에서 우회전 후 네번째 건물까지 와.

선언형(WHAT): 우리 집은 스터디대로 192번길이야.

명령형 프로그래밍은 ‘알고리즘’을 명시하고 목표는 명시하지 않는 데 반해 선언형 프로그래밍은 **‘목표’를 명시하고 알고리즘을 명시하지 않습니다**.

2. 또 다른 정의에 따르면, 프로그램이 함수형 프로그래밍 언어, 논리형 프로그래밍 언어, 혹은 제한형 프로그래밍 언어로 쓰인 경우에 “선언형”이라고 한다.

여기서 “선언형 언어”라는 것은 명령형 언어와 대비되는 이런 프로그래밍 언어들을 통칭하는 것입니다.

첫번째 정의는 방법론 관점의 정의이고, 두 번째는 언어 관점의 정의입니다.

그렇다면 실제 코드는 어떻게 작성해야 할까요?

### 선언형 프로그래밍과 명령형 프로그래밍의 예시

자바스크립트를 사용해 배열에서 짝수를 필터링하는 예시를 확인해보겠습니다.

**선언형 프로그래밍 (Declarative Programming)**

```tsx
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evenNumbers = numbers.filter((num) => num % 2 === 0);

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

위 코드는 `evenNumbers`라는 배열에 `filters()` 메서드를 사용해 `num % 2 === 0` 조건에 맞는 요소들만 필터링해 저장합니다.

짝수를 ‘어떻게(HOW)’ 필터링해야 하는지가 아닌, 짝수를 필터링한 ‘결과(WHAT)’를 얻는 것에 초점이 맞춰져 있으며, `filter`라는 추상화를 통해 “짝수를 골라라”라는 비즈니스 로직만 납깁니다.

이는 선언형 프로그래밍의 특징 중 하나로 ‘데이터를 어떻게 조작해야 하는지’가 아니라, ‘**원하는 데이터는 무엇인지**’에 집중하는 모습입니다.

이와 같은 선언형 프로그래밍은 전체적인 **가독성**과 **추상화 수준**을 높여, **재사용성** 또한 높일 수 있고 **병렬 처리**에도 유리합니다.

**명령형 프로그래밍(Imperative Programming)**

```tsx
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = [];

for (let i = 0; i < numbers.length; i++) {
  const num = numbers[i];
  if (num % 2 === 0) {
    evenNumbers.push(num);
  }
}

console.log(evenNumbers); // [2, 4, 6, 8, 10]
```

이전의 선언형 프로그래밍과 달리 ‘`numbers` 배열의 길이만큼 반복’, ‘만약 `num`이 2로 나누어떨어진다면 `evenNumbers` 배열에 `num` 변수를 push’ 등 문제를 해결하는 과정이 코드에서 드러납니다.

이처럼 명령형 프로그래밍에서는 상태와 제어 흐름을 명시적으로 관리하는 방식으로 코드를 작성합니다.

따라서 코드의 가독성이 저하되거나 재사용성이 낮아질 수 있어 코드 관리에 많은 노력이 필요합니다.

## 함수형 프로그래밍

함수형은 선언형의 특성을 ‘수학적 함수와 불변성’을 통해 구현한 형태입니다.

명령형 언어가 튜링 머신에 기반하고 있다면, 함수형 언어는 **람다대수에 기반**하고 있는 언어 및 그러한 프로그래밍 패러다임에 대한 총칭입니다.

함수형 프로그래밍은 거의 모든 것을 **순수 함수**로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 합니다.

### 람다 대수(λ-calculus)

> 함수(function)만으로 모든 계산을 표현할 수 있음을 보여주는 수학적 계산 모델.
> 상태나 변수 변경 없이 순수 함수로 구성

**핵심 개념**

- 변수 (Variable): x, y, z처럼 이름을 가진 값
- 함수 정의 (Abstraction): 어떤 입력에 대해 계산하는 방법을 정의
  - 표기: `λx. x + 1` → "x를 입력받아 x + 1을 반환하는 함수"
- 함수 적용 (Application): 함수를 어떤 값에 적용하여 실행
  - 표기: `(λx. x + 1) 3` → 결과: `4`

**예시**

```
λx. x     ← "자신을 반환하는 함수" (identity function)
(λx. x) 5 ← "5를 넣으면 5를 반환" → 결과는 5
```

```
λx. λy. x + y   ← "두 수를 더하는 함수" (커링 형태)
((λx. λy. x + y) 2) 3 → 결과는 5
```

```
λf. λx. f(f(x)) ← "함수를 두 번 적용" (compose twice)
```

람다 대수는 함수형 언어의 이론적 기반입니다.

1936년, 알론조 처치(Alonzo Church)는 람다 대수를 통해 튜링 머신과 동등한 계산 능력(튜링 완전성)을 가진 모델을 제시했고 이 모델은 상태, 변수, 반복문 없이도 **함수 정의와 적용만으로 모든 계산 가능함을 증명**했습니다.

이로써 람다 대수는 ‘**계산 가능한 모든 것을 함수로 표현할 수 있다**’는 철학적 기반이 되었고, 이는 곧 함수형 프로그래밍 패러다임의 철학과 정확히 일치합니다.

알론조 처치의 제자였던 존 멕카시(John McCarthy)가 람다 대수를 바탕으로 현대 함수형 언어의 시초인 LISP를 설계했으며, 이후 등장한 Haskell, ML, Scheme 등의 함수형 언어는 람다 대수를 프로그래밍 언어로 실현한 사례입니다.

### 함수형 프로그래밍에 대한 이해

함수형 프로그래밍(Functional Programming)은 **순수 함수**와 **불변성**을 기반으로, 대입문과 상태 변경을 최대한 지양하는 **선언적 프로그래밍 스타일**입니다.

1. **명령형 예시: 어떻게(HOW) 구현할 지 기술**

```tsx
for (let i = 0; i < 10; i++) {
  console.log(i);
}
```

여기서는 `i`라는 변수를 선언하고, 반복할 때마다 그 값이 변경되며 출력 동작이 이루어집니다.

상태 변경이 코드 곳곳에 드러나므로, 로직의 핵심(숫자를 출력한다)과 실행 과정(변수 i를 증가시킨다)이 뒤섞여 있습니다.

1. **함수형 예시: 무엇(WHAT)을 할 지 기술**

```tsx
function process(n, action) {
  [...Array(n).keys()].forEach(action);
}

process(10, console.log);
```

이 코드에서 `process`는 첫 번째 인자로 반복 횟수 `count`를, 두 번째 인자로 실행할 함수 `action`을 받습니다. `process(10, console.log)`라고 선언만 하면, 내부적으로 0부터 9까지를 생성해 `console.log`를 한 번에 적용합니다.

출력 함수를 직접 매개변수로 전달할 수 있는 이유는 자바스크립트에서 함수가 **일급 객체(first-class citizen)**이기 때문이며, 선언형 스타일 덕분에 ‘무엇을 하고 싶은지’가 코드에 깔끔하게 드러납니다.

### 함수형 프로그래밍의 특징

1. **일급 객체(First-Class Citizens) / 고차 함수(Higher-Order Functions)**

   함수형 프로그래밍에서는 **함수(function)를 다른 값과 똑같이 다룹니다**. 즉, 함수를 변수에 할당할 수도 있고, 다른 함수의 매개변수로 넘길 수도 있으며, 함수 호출의 결과로 함수를 돌려받을 수도 있습니다.

   예를 들어, 자바스크립트에서

   ```tsx
   const twice = (x) => x * 2; // 함수를 변수에 담기

   function apply(fn, value) {
     return fn(value); // 함수를 매개변수로 전달
   }

   const result = apply(twice, 5); // apply의 반환값으로 함수 실행
   // result === 10
   ```

   이처럼 함수가 **‘값’이자 ‘동작’**으로써 완전히 동등하게 취급되므로, 작은 단위의 로직들을 손쉽게 조합(composition)하고 재사용할 수 있게 됩니다.

   **고차 함수(Higher-Order Functions)는** 이러한 일급 객체로서의 함수를 매개변수로 받거나, 함수 자체를 반환하는 함수입니다.

   고차 함수를 활용하면 공통 로직을 추상화하여 코드 중복을 제거하고, 다양한 기능을 동적으로 조합할 수 있습니다.

   ```tsx
   // 함수를 반환하는 고차 함수: 커링(Currying) 예시
   const add = (x) => (y) => x + y;
   const increment = add(1);
   console.log(increment(5)); // 6

   // 함수를 매개변수로 받는 고차 함수: 실행 전후에 로그를 남기는 래퍼
   function withLogging(fn) {
     return (...args) => {
       console.log("Calling with", args); // 실행 전 로그
       const result = fn(...args);
       console.log("Result is", result); // 실행 후 로그
       return result;
     };
   }

   // twice라는 함수는 “숫자를 두 배로 만드는 기계”라고 생각할 수 있음.
   const loggedTwice = withLogging(twice);
   loggedTwice(3);
   // Calling with 3
   // Result is 6
   ```

2. **무상태성(Statelessness) / 순수 함수(Pure Functions)**

   함수형 프로그래밍에서는 **함수가 외부 상태나 전역 변수에 의존하거나 변경하지 않습니다**.

   같은 입력을 주면 언제나 같은 출력을 반환하므로, 실행 순서에 따른 예기치 않은 버그가 발생할 여지가 크게 줄어듭니다.

   이러한 함수가 바로 **순수 함수**입니다.

   ```tsx
   // 순수 함수 예시
   const add = (a, b) => a + b;
   add(2, 3); // 언제 호출해도 항상 5

   // 비순수 함수 예시 (상태 변경)
   let counter = 0;
   function inc() {
     counter += 1;
     return counter;
   }
   ```

   순수 함수의 장점은 **테스트와 디버깅이 쉽고**, **병렬 처리**에도 안전하다는 점입니다.

   또한 함수 호출 결과를 캐시에 저장해두는 **메모이제이션(memoization)** 기법을 통해 비용이 큰 계산을 효율적으로 관리할 수 있습니다.

3. **불변성(Immutability)**

   불변성은 “한 번 정의된 데이터를 변경하지 않는다”는 원칙입니다.

   함수형 언어에서는 객체나 컬렉션을 수정할 때, 내부 상태를 직접 바꾸지 않고 **새로운 복사본**을 만들어 반환합니다.

   ```tsx
   const arr = [1, 2, 3];

   // 불변 방식으로 새 배열 생성
   const newArr = [...arr, 4]; // arr은 그대로 [1,2,3], newArr은 [1,2,3,4]
   ```

   이렇게 하면 **값의 흐름**이 코드 전체에서 명확해지고, 예상 외의 사이드 이펙트(부수 효과)를 방지할 수 있습니다.

   여러 컴포넌트가 동일한 데이터를 읽을 때, 어느 한 곳에서 수정되어 다른 곳이 깨지는 문제도 사라집니다.

<br/>

> 참고
>
> - https://yozm.wishket.com/magazine/detail/2083/
> - https://zeunny.hashnode.dev/declarative-programming
> - [https://velog.io/@turtle601/프로그래밍-패러다임에-대해선언형-vs-명령형](https://velog.io/@turtle601/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%A0%EC%96%B8%ED%98%95-vs-%EB%AA%85%EB%A0%B9%ED%98%95)
> - [https://namu.wiki/w/함수형 프로그래밍](https://namu.wiki/w/%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
> - [https://namu.wiki/w/람다 대수?from=람다대수](https://namu.wiki/w/%EB%9E%8C%EB%8B%A4%20%EB%8C%80%EC%88%98?from=%EB%9E%8C%EB%8B%A4%EB%8C%80%EC%88%98)
> - https://mangkyu.tistory.com/111
