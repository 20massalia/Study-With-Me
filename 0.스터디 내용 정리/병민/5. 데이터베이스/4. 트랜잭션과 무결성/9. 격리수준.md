# 트랜잭션 격리수준 (Transaction Isolation Level)

트랜잭션의 격리 수준이란, 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것입니다.

격리 수준은 **동시성과, 데이터 정합성**에 따라서 조절해야 합니다. 

격리 수준은 4가지가 존재합니다.

- READ UNCOMMITTED 
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

READ UNCOMMITTED -> SERIALIZABLE로 갈수록 데이터 정합성이 잘 지켜지고, 동시성이 떨어지게 됩니다.

즉 READ UNCOMMITTED는 가장 동시성이 좋은 대신에 데이터 정합성이 잘 지켜지지 않을 수 있고, SERIALIZABLE은 가장 데이터 정합성을 잘 지킬 수 있는 대신에 동시성이 좋지 않습니다.

## Transaction 격리 수준에 따라 발생할 수 있는 데이터 정합성 문제점

Transaction 격리 수준에 따라 발생할 수 있는 데이터 정합성 문제점에는 크게 다음과 같은 3가지가 존재합니다.

- DIRTY READ
- NON-REPEATABLE READ
- PHANTOM READ

### 1. DIRTY READ

![DIRTY READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbB9kNG%2Fbtsv8TW0sce%2FAAAAAAAAAAAAAAAAAAAAAN3PoZp5hJptN0LnV8oBsezJXeWFx6UbzZWsE5XqUf3x%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3D0I4cZ2PWOcD8dc%252B6eqOgCEEDXRw%253D)

1. 트랜잭션 A에서 MEMBER 테이블에 '승하' Member Insert
2. 트랜잭션 B에서 MEMBER SELECT
3. 트랜잭션 A 커밋

이러한 Dirty Read 현상은 트랜잭션 A가 롤백된다고 했을 때,

트랜잭션 B에서는 Insert된 Member까지 Select되어 최종 결과와 달라질 수 있다는 점에서 문제가 될 수 있습니다.

### 2. NON-REPEATABLE READ (REPEATABLE READ 불가능)

![NON-REPEATABLE READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FctnlhU%2FbtsxtT8q815%2FAAAAAAAAAAAAAAAAAAAAAH1wbxEUqW13N_KL5qRSRjjwE_7tjajZ6bHaXfS1IUQh%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DIJEpP4gfXOCZO%252B1%252BQANNE9vQhvA%253D)

1. 트랜잭션 B에서 ACCOUNT 테이블에 account_id가 1인 레코드 조회 : Money 값 1000
2. 트랜잭션 A에서 ACCOUNT 테이블에 account_id가 1인 레코드의 money 2000으로 변경
3. 트랜잭션 A 커밋
4. 트랜잭션 B에서 ACCOUNT 테이블에 account_id가 1인 레코드 조회 : Money 값 2000

이렇게 SELECT 쿼리를 실행 했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ가 지켜지지 않는 문제가 바로

NON-REPEATABLE READ입니다.

이러한 문제는 다음과 같은 상황에서 치명적일 수 있습니다.

- 위의 상황이 계좌의 잔액 조회라고 가정
- 처음 조회된 계좌의 잔액이 1000원일 때 사용자는 해당 잔액으로 작업을 처리할 것입니다. (500원 송금 등)
- 사용자가 500원을 송금하는 작업 과정 중 현재 잔액을 다시 확인하는 과정이 있음
  - 이때, 처음 계좌 잔액 조회와 500원 송금 작업 사이에 누군가 사용자에게 1000원을 입금했다면 송금 시 현재 계좌 잔액이 2000원으로 보여질 것입니다.
- 이러한 상황은 사용자에게 혼란을 야기할 수 있습니다.

이렇게 데이터의 정합성이 깨질 수 있습니다.

### 3. PHANTOM READ

![PHANTOM READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FVzSxJ%2Fbtsv7AcENAr%2FAAAAAAAAAAAAAAAAAAAAAJitsASmce393iEnx4vWWFG1C1KKyBpVQXZ7TANzvpmp%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3Dh05wPi933n%252B8Rcq3EwM59u59Qfg%253D)

1. 트랜잭션 B에서 PRODUCT 테이블의 모든 PRODUCT SELECT : Water
2. 트랜잭션 A에서 PRODUCT 테이블에 PRODUCT 'Pizza' 추가
3. 트랜잭션 A 커밋
4. 트랜잭션 B에서 PRODUCT 테이블의 모든 PRODUCT SELECT : Water, Pizza

이렇듯, 다른 트랜잭션에서 수행한 변경 작업(커밋된 변경 작업)에 의해

이전 조회 레코드에서 존재하지 않았던 레코드가 조회 시 새롭게 추가되어 나타나는 현상을 PHANTOM READ라고 합니다.

이는 NON-REPEATABLE READ와 조회 결과가 다르다는 점이 비슷하지만,

NON-REPEATABLE READ는 이전의 결과 레코드 대상은 같지만 값이 변한 것이고

PHANTOM READ는 이전의 결과 레코드 자체에서 없었던 레코드가 추가로 생성된 것에서 차이가 있습니다.

## Transaction 격리 수준의 특징

각 Transaction 격리 레벨의 특징과 어떤 데이터 정합성 문제 있을 수 있습니다.

### 1. READ UNCOMMITTED

각 트랜잭션의 변경 내용이 COMMIT, ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 조회되는 격리 수준입니다.

위와 같은 특성을 통해서 위에서 살펴본 데이터 정합성 문제들을 전부 가지게 됩니다.

- DIRTY READ: 다른 트랜잭션이 커밋되지 않았을 때 다른 트랜잭션의 쿼리 샐행 결과가 조회
- NON-REPEATABLE READ: 항상 똑같은 조회 결과가 아니라 다른 트랜잭션의 결과에 따라 조회 결과가 변함
- PHANTOM READ: 다른 트랜잭션의 레코드 추가 작업이 발생하면 없었던 레코드가 조회시 나타남

이러한 위와 같은 문제점을 가지기 때문에 데이터 정합성 측면에서 가장 좋지 않은 격리 레벨입니다. 하지만 DB Lock이 거의 사용되지 않아서 동시성이 좋아집니다.

### 2. READ COMMITED

커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리수준입니다.

위의 READ UNCOMMITTED에서 보았던 문제중에 DIRTY READ가 빠지게 되어서 아래와 같은 2가지 문제만 발생합니다.

- NON-REPEATABLE READ: 항상 똑같은 조회 결과가 아니라 다른 트랜잭션의 결과에 따라 조회 결과가 변함
- PHANTOM READ: 다른 트랜잭션의 레코드 추가 작업이 발생하면 없었던 레코드가 조회시 나타남

READ COMMITTED는 '커밋이 완료된 트랜잭션의 변경사항만 조회'하기 때문에 커밋 되기 이전 결과가 조회되는 DIRTY READ 문제는 해결할 수 있습니다.

기본적으로 가장 많이 사용하는 트랜잭션 격리 수준으로 오라클 DB에서 사용한다고 합니다.

### 3. REPEATABLE READ

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준입니다.

- PHANTOM READ: 다른 트랜잭션의 레코드 추가 작업이 발생하면 없었던 레코드가 조회시 나타남

위와 같은 정합성 문제만 발생합니다. 

REPEATABLE READ는 '트랜잭션 시작 전 존재하는 레코드 조회'에 관해서는 항상 동일한 결과를 보장합니다. 따라서 다른 트랜잭션의 커밋 시점 후에 조회 결과가 변하지 않으므로, NON-REPEATABLE READ 문제를 해결할 수 있습니다.

하지만, 추가되는 레코드에 대해서는 동일한 조회 결과를 보장하지 않으므로 PHANTOM READ가 발생할 수 있습니다.

### REPEATABLE READ - 예제

일반적인 RDBMS는 변경 전의 레코드를 Undo Space에 백업 해 둡니다. 
그러면 변경 전/후 데이터가 모두 존재하므로, 공일한 레코드에 대해 여러 버전의 데이터가 존재한다고하여 이를 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)라고 부릅니다.
MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있습니다.
각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 ID로 존재하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호화 함께 저장합니다.
그리고 해당 데이터가 더 이상 불필요하다고 판단하는 시점에 백그라운드 스레드를 통해 삭제합니다.

아래의 그림을 통해서 예시를 살펴볼 수 있습니다.

![REPEATABLE READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fpzv2A%2FbtsgE65gQXu%2FAAAAAAAAAAAAAAAAAAAAAJQ-kc6nvU__77OXwnXeJ7CBGCfB4tZYIsVG46qcKQu5%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DtcN6Ud41iMUfe%252B%252Bc3w7zY%252BNxvaM%253D)

이러한 REPEATABLE READ는 MVCC를 통해서 한 트랜잭션 내에서는 동일한 결과를 보장하지만, 새로운 레코드가 생긴 경우에는 데이터 부정합이 생길 수 있습니다.

#### MySQL에서의 REPEATABLE READ

또한, MySQL의 InnoDB엔진의 기본 격리 수준은 REPETABLE READ입니다.

기본적으로 MySQL에서 기본 격리 수준으로 REPAEATABLE READ을 설정하면 데이터 정합성 문제들이 모두 해결되기 때문에 MySQL의 기본 격리 수준으로 REPAEATABLE READ을 설정한 것 같습니다.

- SELECT ... FOR UPDATE : 베타 락
- SELECT ... FOR SHARE : 공유 락

MySQL에는 갭 락이 존재하기 때문에 위의 PHANTOM READ 상황에서 문제가 발생하지 않습니다.

사용자 B가 SELECT FOR UPDATE로 데이터를 조회한 경우에 MySQL은 id가 50인 레코드에는 레코드 락, id가 50보다 큰 범위에는 갭 락으로 넥스트 키 락을 겁니다.
따라서 사용자 A가 id가 51인 member를 INSERT 시도한다면, B의 트랜잭션이 종료(커밋 또는 롤백)될 때 까지 기다리다가, 대기를 지나치게 오래 하면 락 타임아웃이 발생하게 됩니다.

![MySQL에서의 REPEATABLE READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbrEv6m%2FbtsgE74aCWs%2FAAAAAAAAAAAAAAAAAAAAAGN1Yxw-C3L8vbdv2ZOWST3cCsfI1WlLL_ElFb3SS40p%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DmM6sONdku%252BK48%252B75GHkIWHsUX1o%253D)

따라서 일반적으로 MySQL의 REAPEATABLE READ에서는 Phantom Read가 발생하지 않습니다. MySQL에서 PHANTOM READ가 발생하는 상황의 유일한 케이스는 아래와 같습니다.

![MySQL에서의 REPEATABLE READ](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FzqWEC%2FbtsgKnZf2hw%2FAAAAAAAAAAAAAAAAAAAAAE99yYqySuhZYXxHr8am6Xy6bWkC9A6U1mo1umfrUOrg%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DJIYXwseGSZlmrI3YyqSXBgkqXAQ%253D)

하지만 이러한 케이스는 거의 존재하지 않으므로, MySQL의 REPEATABLE READ에서는 PHANTOM READ가 발생하지 않는다고 봐도 됩니다. 아래는 MySQL 기준으로 정리된 내용입니다.

- SELECT FOR UPDATE 이후 SELECT: 갭락 때문에 팬텀리드 X
- SELECT FOR UPDATE 이후 SELECT FOR UPDATE: 갭락 때문에 팬텀리드 X
- SELECT 이후 SELECT: MVCC 때문에 팬텀리드 X
- SELECT 이후 SELECT FOR UPDATE: 팬텀 리드 O

### 4. SERIALIZABLE

하나의 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없는 격리 수준입니다.

하나의 트랜잭션에서 작업하는 레코드에 다른 트랜잭션에서 접근할 수 없기 때문에 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준입니다.

따라서, READ UNCOMMITTED와 반대로 데이터 정합성이 가장 잘 지켜지는 격리 수준이지만 데이터 정합성에 엄격하기 때문에 DB Lock이 많이 걸려서 동시성이 가장 좋지 않습니다.

## Reference

https://ksh-coding.tistory.com/118?category=1084491
https://mangkyu.tistory.com/299