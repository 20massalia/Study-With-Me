# Redis

## 개념

Redis는 메모리 기반 **키-값 데이터 스토어**로, 싱글 스레드 이벤트 루프 구조와 다양한 **자료구조(String/Hash/List/Set/Sorted Set/Bitmap/HyperLogLog/Geo/Streams)** 를 제공하여 **극저지연** 읽기·쓰기를 지원합니다.  
주요 활용: **캐시**, **세션/토큰 저장**, **카운터/랭킹**, **이벤트 스트리밍(Streams)**, **일시 데이터 처리**.

## 특징
- **빠름**: 메모리 연산 + 싱글 스레드(대부분 O(1)~O(logN)).
- **풍부한 자료구조**: 문제 유형별 최적 연산 제공.
- **TTL/만료 & Eviction**: 키 단위 만료, LRU/LFU 등 퇴출 정책.
- **원자성/트랜잭션**: 단일 명령 원자성, MULTI/EXEC, WATCH(CAS), Lua 스크립트.
- **영속성 옵션**: RDB 스냅샷, AOF(Append Only), 혼합(RDB+AOF).
- **확장/HA**: Replication, Sentinel(자동 장애조치), Cluster(16384 슬롯 샤딩).
- **네트워킹**: 파이프라이닝, Pub/Sub(NRT 브로드캐스트), Streams(내구성 큐/로그).

---

## Redis 자료구조

| 구조 | 대표 명령 | 복잡도(대략) | 사용 예시 / 설계 팁 |
|---|---|---:|---|
| **String** | `SET`, `GET`, `INCR`, `SETEX` | O(1) | 토큰/세션, 카운터, 간단 JSON. `SET key val NX EX 60`으로 **원자적 set-if-absent + TTL**(락/캐시 채우기). |
| **Hash** | `HSET`, `HGET`, `HMGET`, `HSCAN` | O(1)~ | 사용자 프로필, 속성 맵. 필드 단위 접근. 필드 과다 시 메모리 단편화 주의. |
| **List** | `LPUSH`, `RPUSH`, `BLPOP` | O(1) | 간단 큐/스택, 최근 N개 기록. **중간 삭제 비효율**. |
| **Set** | `SADD`, `SCARD`, `SINTER` | O(1)~O(N) | **고유 집합**(중복 제거), 친구/태그, **일별 활성 사용자(DAU)**. |
| **Sorted Set** | `ZADD`, `ZREVRANGE`, `ZRANK` | O(logN)+ | **랭킹/리더보드**, 타임라인(스코어=타임스탬프). 범위 질의·Top-K. |
| **Bitmap** | `SETBIT`, `BITCOUNT` | O(1)/O(N/8) | 초경량 **불리언 플래그** 대량 집계(출석/DAU). userId → 연속 인덱스 매핑 필요. |
| **HyperLogLog** | `PFADD`, `PFCOUNT` | O(1) | **근사 고유수(Unique)** 집계. 메모리 극소(≈12KB), 오차≈0.81%. |
| **Geo** | `GEOADD`, `GEORADIUS` | O(logN) | 반경 검색(매장 찾기). 내부적으로 ZSet 사용. |
| **Pub/Sub** | `PUBLISH`, `SUBSCRIBE` | - | 초저지연 브로드캐스트. **내구성/리플레이 없음**(유실 허용). |
| **Streams** | `XADD`, `XREADGROUP`, `XACK` | O(logN) | **내구성 있는 로그/큐**. 소비자 그룹, ACK/재처리, 백프레셔. SSE/이벤트 파이프 적합. |

> 대량 키 탐색 시 `KEYS`(블로킹) 금지 → **`SCAN`**(cursor) 사용.

---

## 4) 영속성(데이터 유지)

| 모드 | 설명 | 장점 | 단점/주의 |
|---|---|---|---|
| **RDB** | 주기적 스냅샷(`dump.rdb`) | 파일 작음, 복구 빠름 | 스냅샷 간격 사이 데이터 유실 가능 |
| **AOF** | 명령 Append(`appendonly.aof`) | 내구성↑(`everysec/always`), 재생 복구 | 파일 증가 → **Rewrite** 필요, I/O 부담 |
| **혼합** | RDB+AOF 병용 | 복구속도/내구성 균형 | 설정 복잡도 소폭↑ |

- `appendfsync=everysec` 권장(최대 1초 유실 허용).
- RDB 저장/AOF Rewrite는 **fork + COW** → 순간 메모리 여유 필요.

---

## 5) 복제/고가용성/확장
- **Replication**: 리더-레플리카(기본 비동기). 읽기 스케일아웃, 지연 모니터링.
- **Sentinel**: 리더 감시 + **자동 Failover**(최소 3개 권장).
- **Cluster**: **16384 해시 슬롯** 기반 샤딩/복제.
	- 멀티키 연산은 **같은 슬롯**에서만 가능 → **해시태그 `{...}`** 로 슬롯 고정.
	- 슬롯 재분배/리밸런싱, `MIGRATE` 절차 숙지.

---

## 6) 메모리 관리 & 성능
- `maxmemory` + **Eviction 정책**:
	- `noeviction` / `volatile-ttl|lru|lfu|random` / `allkeys-lru|lfu|random`
	- 최신 트래픽 반영에는 **LFU** 유리.
- **TTL 지터**: 만료 동시폭주(캐시 스탬피드) 방지 위해 TTL에 무작위 편차 부여.
- **Big Key 지양**: 단일 키에 수십만 요소 → 지연/타임아웃. **분할/샤딩**.
- **Pipeline** 적극 활용: RTT 절약, 대량 처리 효율↑.
- BGSAVE/AOF Rewrite 시 **메모리 단편화·스왑** 주의(컨테이너 제한 확인).

---

## 7) 트랜잭션/락/원자성
- **단일 명령은 원자적**(싱글 스레드).
- **MULTI/EXEC**: 큐잉 후 일괄 실행(중간 실패는 앱에서 보정).
- **WATCH**: 낙관적 락(CAS). 키 변경 시 `EXEC` 실패.
- **Lua(EVAL)**: 서버 측 **원자적** 스크립트(다중키·복합 로직 안전).
- **분산락**: `SET key val NX PX 30000` 기본형. Redlock은 논쟁적 → 가능하면 단일 Redis + 적정 TTL, 또는 **Redisson 등 검증 구현** 사용.

---

## 8) 운영 체크리스트
- **보안**: `protected-mode yes`, 사설망, `AUTH/ACL`, 필요 시 TLS.
- **모니터링**: `INFO`, `SLOWLOG`, CPU/메모리/네트워크, 레플리카 지연, p95/p99.
- **백업**: RDB + AOF 스냅샷, **오프사이트** 보관, 복구 리허설.
- **용량 계획**: (키 수 × 평균 값 크기 + 오버헤드) × **2~3배 버퍼**.
- **버전/모듈 관리**: 복제본에서 롤링 업그레이드, 호환성 확인.
- **클러스터 운영**: 슬롯 균형, `CLUSTER KEYSLOT`, 재샤딩 절차 문서화.

---

## 9) 자주 쓰는 패턴

### 9.1 Cache-Aside
1) 캐시 조회 → 미스
2) DB 조회 → 캐시에 `SETEX`(TTL + **지터**) → 응답
- **스탬피드 방지**: TTL 지터, **분산 뮤텍스**(핫키 계산 단일화), 요청 합치기(한 스레드만 생성).

### 9.2 랭킹(정렬셋)
```bash
ZINCRBY leaderboard 1 user:42
ZREVRANGE leaderboard 0 9 WITHSCORES   # Top 10
ZRANK leaderboard user:42               # 내 순위
