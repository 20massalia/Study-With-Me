## 객체지향 프로그래밍 (Object-Oriented Programming, OOP)

**객체지향 프로그래밍**은 프로그래밍에서 필요한 데이터를 **추상화**시켜 **상태와 행위를 가진 객체로 만들고**, **객체들간의 상호작용을 통해 로직을 구성**하는 프로그래밍 방법입니다. **현실 세계에 존재하는 대상을 모델로 컴퓨터 프로그램으로 만드는 일**이라고 할 수 있습니다.

### 객체지향 프로그래밍의 기본 개념

**객체지향 프로그래밍**은 많은 **객체들이 모여서 상호 협력하면서 데이터를 처리**하는 방식의 프로그래밍 설계 방법을 의미합니다. 즉, **프로그램을 묶음 단위로 잘게 쪼개서 추후에 가져다 쓰기 편하게 만들어 놓은 프로그래밍 방식**입니다.

### 객체(Object)와 클래스(Class)

**객체**는 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, **값을 저장할 변수와 작업을 수행할 메서드를 서로 연관된 것들끼리 묶어서 만든 것**입니다.

**클래스**는 **객체의 설계도 역할**을 하며, 설계도를 바탕으로 만들어진 실제 객체를 **인스턴스**라고 합니다.

### 객체지향 프로그래밍의 4가지 특징

1. **추상화(Abstraction)**
   
    **추상화**는 **복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것**입니다.

2. **캡슐화(Encapsulation)**

    **캡슐화**는 **객체의 데이터와 메서드를 하나로 묶고, 외부에서 객체의 내부 상태에 직접 접근하지 못하도록 제한**하는 것입니다. **속성과 기능을 정의하는 변수와 메서드를 클래스라는 캡슐에 넣어 분류**하는 것으로 **재활용성을 높이고**, **캡슐화를 통해 정보은닉을 활용**할 수 있습니다.

3. **상속(Inheritance)**

    **상속**은 **기존 클래스의 속성과 메서드를 새로운 클래스가 물려받아 사용**하는 것입니다. **재사용성을 높이지만**, 상위 클래스의 변경이 어려워지며 불필요한 클래스가 증가될 수 있습니다.

4. **다형성(Polymorphism)**

    **다형성**은 **하나의 클래스 내부에 같은 이름의 행위를 여러 개 정의**하거나 **상위 클래스의 행위를 하위 클래스에서 재정의**할 수 있는 특징입니다. 이에 **오버라이딩과 오버로딩**이 있습니다.

### 객체지향 프로그래밍의 장점

- **유지보수성과 유연성**
- **코드 재사용성**
- **직관성과 가독성**

> 많은 데이터를 다루는 프로그램이나, 규모가 큰 프로젝트 같은 경우에는 이 **객체지향의 장점이 더 부각**됩니다.

### 객체지향 프로그래밍의 단점

- **성능 관련 단점**
  - 처리속도가 상대적으로 느림
  - 용량이 커질 수 있음
- **설계 관련 단점**
  - 설계에 많은 시간과 노력이 듦
  - 설계가 어려움

> **극도로 빠른 실행 속도가 필요한 분야** 혹은 **저장 장치나 성능이 제한적인 기기**. 즉, **임베디드와 같은 특정 분야에는 부적합**합니다.

## SOLID 원칙

![예시사진1](https://velog.velcdn.com/images/haero_kim/post/169ef81a-0c8c-4241-a73a-135d5b67ffea/1_XOMTPWTpDLypkp079p9XXg.png)

**SOLID 원칙**은 **객체지향 프로그래밍에서 지켜야 할 5가지 핵심 설계 원칙**으로, **시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발**하는데 도움이 됩니다. **응집도는 높이고, 결합도는 낮추는 원칙을 객체지향의 관점에서 재정립**한 것입니다.

> 이 원칙들은 **서로 독립적이지 않고 상호 연결**되어 있어, **한 가지 원칙만 잘 지켜도 나머지 원칙들이 저절로 지켜지는 특성**을 가집니다.

### 1. Single Responsibility Principle (단일 책임 원칙)

**단일 책임 원칙**은 **한 클래스는 하나의 책임(기능)만 가져야 한다**는 원칙입니다. 

#### 핵심 개념

하나의 클래스가 수행하는 기능이 여러 개라면, **클래스 내부의 함수끼리 강한 결합을 가질 가능성이 높아지고 코드의 효율이 떨어집니다**. **객체지향 설계의 핵심인 높은 응집도와 낮은 결합도를 지키지 못하게** 되는 것입니다.

```java
class ExampleClass {
    public void executeA() {
        System.out.println("A 실행 -> " + executeB());
    }

    public String executeB() {
        return "B 실행 ->" + executeC();
    }

    public String executeC() {
        return "C 실행";
    }
}
```

### 2. Open-Closed Principle (개방 폐쇄 원칙)

**개방-폐쇄 원칙** 은 **"소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다"** 는 원칙입니다.

#### 핵심 개념

어떤 모듈의 기능을 하나 수정할 때, 그 모듈을 이용하는 다른 모듈들을 줄줄이 고쳐야 한다면 유지보수가 복잡할 것입니다. 따라서 **개방-폐쇄 원칙을 잘 적용하여 기존 코드를 변경하지 않아도 기능을 새롭게 만들거나 변경할 수 있도록** 해야 합니다.

#### 구현 방법

```java
// 개방-폐쇄 원칙을 적용한 예제
interface Shape {
    double calculateArea();
}

class Rectangle implements Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

class Circle implements Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// 새로운 도형을 추가할 때 기존 코드 변경 없이 확장 가능
class Triangle implements Shape {
    private double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}
```

### 3. Liskov Substitution Principle (리스코프 치환 원칙)

**리스코프 치환 원칙** 은 **"프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다"** 는 원칙입니다.

#### 핵심 개념

**자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대신하더라도 의도에 맞게 작동** 되어야 합니다.

#### 중요성

**리스코프 치환 원칙이 지켜지지 않으면 OCP 또한 위반**하게 됩니다. 기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이기 때문입니다. 따라서 **상속관계를 설계할 때 LSP 원칙이 위반되지 않도록 설계** 해야 합니다.

### 4. Interface Segregation Principle (인터페이스 분리 원칙)

**인터페이스 분리 원칙** 은 **"특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다"**는 원칙입니다.

#### 핵심 개념

**각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만드는 것** 이 핵심입니다.

### 5. Dependency Inversion Principle (의존성 역전 원칙)

**의존성 역전 원칙** 은 **"프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안 된다"** 는 원칙입니다.

#### 핵심 개념

**구체화된 클래스에 의존하기보다는 추상 클래스나 인터페이스에 의존**해야 한다는 뜻입니다. **의존성 주입** 은 이 원칙을 따르는 방법 중 하나입니다.

## SOLID 원칙들의 상호관계

**SOLID 원칙들은 서로 밀접하게 연관** 되어 있습니다.

**SRP와 ISP는 객체가 커지는 것을 막아줍니다.** 객체가 단일 책임을 갖도록 하고 클라이언트마다 특화된 인터페이스를 구현하게 함으로써 **한 기능의 변경이 다른 곳까지 미치는 영향을 최소화** 하고, 이는 **기능 추가 및 변경에 용이** 하도록 만들어 줍니다.

**LSP와 DIP는 OCP를 서포트합니다.** **OCP는 자주 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장에는 용이하되 기존 코드의 변화에는 보수적이도록** 만들어 줍니다. 여기서 **'변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP** 이고, **다형성 구현을 도와주는 원칙이 LSP** 인 것입니다.

## SOLID 원칙의 목적과 효과

**SOLID 원칙들은 모두 '결합도는 낮게, 응집도는 높게'라는 공통 목적**을 가지고 있습니다.

- **시간이 지나도 변경이 용이한 소프트웨어 개발**
- **유지보수와 확장이 쉬운 시스템 구축**
- **코드의 유연성, 재사용성, 유지보수성 향상**
- **소스 코드가 읽기 쉽고 확장하기 쉬운 구조 달성**

**SOLID 원칙**은 **애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부**로, **프로그래머가 소프트웨어 소스 코드를 리팩터링하여 코드 스멜을 제거하기 위해 적용할 수 있는 지침 역할**을 합니다.

#### Reference

http://velog.io/@haero_kim/SOLID-%EC%9B%90%EC%B9%99-%EC%96%B4%EB%A0%B5%EC%A7%80-%EC%95%8A%EB%8B%A4

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID

https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99