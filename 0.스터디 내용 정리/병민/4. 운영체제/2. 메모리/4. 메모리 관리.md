# 메모리 관리

가상 메모리, 스레딩, 메모리 할당, 페이지 교체 알고리즘

## 1. 가상 메모리(Virtual Memory)

가상 메모리란 실제 물리 메모리(RAM) 용량보다 더 큰 가상 주소 공간을 각 프로세스에 제공하는 운영체제의 기술입니다.

페이징, 세그멘테이션(혹은 혼합)으로 논리적 주소와 물리적 주소를 분리합니다.

![가상 메모리](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRdNZbH1Yoh8DDsjbsW0HNWBLCVCiuZzdTGtg&s)

### 가상 메모리의 장점

- 여러 프로그램을 동시에 실행할 수 있고, 프로그램마다 독립적인(충돌이 없는) 주소 공간 보장.
- 메모리 사용 효율 극대화(사용 중인 페이지만 실제 메모리에 올림).
- 보안성 및 프로세스 보호(서로의 메모리 침범 방지).

### 가상 메모리가 가능한 이유

OS와 하드웨어의 발달로 디스크를 메모리처럼 일부 사용할 수 있기 때문에 가능합니다.

- 주소 변환(논리 -> 물리) 하드웨어(MMU)
- OS가 프로그램의 "논리주소"를 실제 "물리주소"와 매핑해주는 소프트웨어, 하드웨어 협력
- 디스크(보조기억장치)를 메모리처럼 일부 사용할 수 있는 환경(스왑 영역 등)

## 2. 스레싱(Thrashing)

![스레싱](https://blog.skby.net/wp-content/uploads/2019/04/1-36.png)

스레싱이란 메모리에서 페이지 폴트가 과도하게 발생하여 대부분의 CPU 시간이 페이징에 낭비되는 현상입니다.

![스레싱](https://blog.skby.net/wp-content/uploads/2019/04/2-15.png)

### 스레싱 완화 방법

- 작업 세트(Working set) 크기 조절: 필요 페이지 수만큼 프레임 할당. 지역성의 원리를 이용해 프로세스가 자주 참조하는 페이지를 묶습니다. 
- Page Fault Frequency, 적응형(Adaptive) 교체 알고리즘 사용. 프로세스의 페이지 부재율을 주기적으로 조사하고 이 값에 근거하여 각 프로세스에 할당할 메모리 양을 동적으로 예측하고 조절하는 알고리즘을 사용합니다.

## 메모리 할당(Memory Allocation)

![메모리 할당](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRXcP_oyG3B5RaYWbHt4xj1n6d1PwUxbQuJUA&s)

내부/외부 단편화: 메모리 할당/해제가 반복되면 사용할 수 없는 '쪼개진' 메모리 영역이 생길 수 있습니다. 이러한 점을 해결하기 위해서 아래와 같은 방식들을 사용합니다.

### 메모리의 연속할당 방식(First-Fit, Best-Fit, Worst-Fit)

| 방식       | 탐색 속도 | 내부 단편화 | 외부 단편화 | 실제 채택 빈도 |
|----------|-------|--------|--------|----------|
| First-Fit	 | 빠름    | 보통     | 있음     | 매우 높음    |
| Best-Fit | 느림    | 적음     | 오히려 많음 | 낮음       |
| Worst-Fit         | 느림    | 보통~많음  | 보통~많음  | 거의 없음    |

현실적으로는 First-Fit이 간결하고 성능이 좋으며, Worst-fit은 특수 목적 아니면 거의 사용되지 않습니다.
Best-fit은 단편화를 완벽히 해결하지 못하고, 오히려 효율이 떨어질 수 있습니다.

## 페이지 교체 알고리즘(Page Replacement Algorithm)

페이지 폴트(Page Fault) 발생 시, 메모리가 가득 차면 어떤 페이지를 내보내고 새로 올릴지 결정하는 알고리즘입니다.

### FIFO: 가장 먼저 들어온 페이지를 교체

![FIFO](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FU5nSm%2Fbtq9PUpYAl8%2FAAAAAAAAAAAAAAAAAAAAAFaHIK6-r3QIrz9goGxiPz4qMzoUTL3cCjyts0UQz_EA%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DRAWHLSAKAJ8SzSwNfPH59p1jupA%253D)

### LRU(Least Recently Used): 가장 오랫동안 사용하지 않은 페이지 교체

![LRU](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fb1csvE%2Fbtq9IZlYnx0%2FAAAAAAAAAAAAAAAAAAAAAKGLL-6U-hMM4QuEJmXlL5HNU3ke9kIrrznx1pRSCuoG%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DqaV3a7ejX%252BLdzAZGEIKzTgSJGeg%253D)

**시간 지역성(Temporal Locality)성질 고려합니다.**

### Optimal: 앞으로 가장 늦게 참조될 페이지 교체(이론상 최적)

![Optimal](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FS8lUX%2Fbtq9JNyN39f%2FAAAAAAAAAAAAAAAAAAAAAF4iNonjAVYjouP0RIlDWZu2VxO0XddEJks-lBP3O6fR%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D5apjxxC6YUMLzYGgvcozyxA%252F1rs%253D)

### LFU(Least Frequently Used): 가장 적게 사용된 페이지 교체

모든 알고리즘은 Hit ratio(페이지 적중률), 구현 복잡성, 추가 오버헤드에 따라 Trade-Off가 발생합니다.

FU는 참조횟수를 통해 장기적 시간규모에서의 참조성향 고려할 수 있습니다.

## Reference

https://velog.io/@gawgjiug/Virtual-Memory-%EB%9E%80
https://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/
https://doh-an.tistory.com/28