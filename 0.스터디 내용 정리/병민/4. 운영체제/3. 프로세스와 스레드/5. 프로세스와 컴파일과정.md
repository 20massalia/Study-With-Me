# 프로세스와 컴파일 과정

## 프로세스

프로세스는 실행중인 프로그램을 의미하며, 운영체제로부터 독립된 자원을 할당 받아 실행되는 단위입니다. 즉, 프로그램이 실행 중인 동적인 상태를 의미합니다.

간단히 정리해 보자면 아래의 표와 같습니다.

| 프로그램                                 | 프로세스                                    |
|--------------------------------------|-----------------------------------------|
| 어떤 작업을 하기 위해 실행 할 수 있는 파일            | 실행되어 작업중인 컴퓨터 프로그램                      |
| 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 정적인 상태 | 메모리에 적제되어 CPU 자원을 할당 받아 프로그램이 실행되고 있는 상태 |
| 그냥 코드 덩어리                            | 실행 중인 코드 덩어리                            |

프로세스의 상태 변화에 대해서 다시 보자면 아래와 같은 그림을 통해 설명할 수 있습니다.

![프로세스의 상태변화](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FKzEt6%2FbtqAgFbc2FS%2FAAAAAAAAAAAAAAAAAAAAAIoUsL-cU9vFbuIwBghWpct5lsTWOluOssKiyFeojkoK%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D5Utnt%252FhUF3xaSDfa1CkXHXCEyko%253D)

프로세스의 상태는 크게 `실행 상태`, `비실행 상태`로 구분되며, 프로세스의 비실행 상태는 준비, 실행, 대기 상태로 구분될 수 있습니다.

## 스레드

스레드는 하나의 프로세스 내에서 동시에 진행되는 작업갈래, 흐름의 단위를 말합니다.

![스레드](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)

하나의 프로세스 안에서 여러가지 작업들이 동시에 진행될 수 있습니다. 오른쪽 그림과 같이 하나의 프로세스 내에서 여러 개의 스레드를 사용한다면 이를 멀티 스레드라고 부릅니다.

스레드 수가 많을 수록 프로그램 속도도 동시에 하는 작업이 많아 처리량이 올라갈 수 있습니다.

### 프로세스와 스레드의 차이

프로세스의 자원 구조는 4가지의 메모리 영역으로 구성되어 있습니다.

1. 코드 영역(Code/Text): 프로그래머가 작성한 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
2. 데이터 영영(Data) : 코드가 실행되며 사용하는 전역 변수나 각종 데이터가 모여있습니다.
    - .data: 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터 저장
    - .BSS: 초기값이 없는 전역 변수, static 변수 저장
    - .rodata: const 같은 상수 키워드 변수나 문자열 상수 저장
3. 스택 영역(Stack): 함수 호출과 종류와 같이 임시적인 자료를 저장하는 공간입니다.
4. 힙 영역(Heap): 생성자, 인스턴스와 같은 동적인 데이터가 할당되는 공간입니다.

### 스레드의 자원공유

스레드는 프로스세가 할당 받은 자원을 이용하는 실행의 단위로서, 스레드가 여러 개 있으면 우리가 파일을 다운 받으며 동시에 웹 서핑할 수 있게 해줍니다. 스레드끼리 프로세스의 자원을 공유하면서 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업이 가능합니다.
따라서 스레드의 상태는 아래의 그림과 같습니다.

![스레드의 자원공유](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)

이 떄 프로세스의 4가지 메모리 역역 중 스레드는 Stack만 할당받아 복사하고, 나머지 코드, 데이터, 힙 영역은 프로세스 내의 다른 스레드들과 공유합니다.

![스레드의 자원공유](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)

### 멀티스레드 단점
1. **안정성 저하**
	- 하나의 스레드에서 오류가 발생하면, 같은 프로세스 내 다른 스레드에도 영향을 미칠 수 있음.
2. **동기화 문제**
	- 공유 자원에 여러 스레드가 동시에 접근하면 데이터 불일치나 충돌이 발생할 수 있음.
	- 적절한 동기화 기법을 사용하지 않으면 **데드락(Deadlock)**이나 **레이스 컨디션(Race Condition)** 발생 가능.
3. **과도한 스레드 생성 시 성능 저하**
	- CPU 코어 수보다 많은 스레드 생성 시 문맥 전환(Context Switching) 비용이 증가해 오히려 성능이 떨어짐.

### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?

1. 자원의 효율성 증대
    - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.
    - 프로세스 간의 컨텍스트 스위칭시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화됨으로 오버헤드가 큽니다.
    - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어듭니다.
2. 처리 비용 감소 및 응답 시간 단축
    - IPC보다 스레드 간의 통신 비용이 적으므로 작업들 간의 통신 부담이 줄어듭니다.
      - 스레드는 Stack 영역을 제외한 모든 메모리를 공유합니다.
    - 프로세스 간의 컨텍스트 스위칭보다 스레드 간 스위칭이 전환 속도가 빠릅니다.
      - 컨텍스트 스위칭시 스레드는 Stack 영역만 처리하면 됩니다.

### 멀티프로세스 장점 (멀티스레드와 비교)
1. **독립성**
	- 각 프로세스는 독립된 메모리 공간을 가지므로, 한 프로세스가 비정상 종료되어도 다른 프로세스에는 영향이 없음.
2. **안정성**
	- 시스템의 일부 모듈이 오류를 일으켜도 전체 시스템이 다운되지 않음.
3. **보안성**
	- 메모리를 공유하지 않으므로 다른 프로세스가 직접 접근하기 어려움.

## 컴파일 과정

자바와 C와 같은 언어에서 컴파일은 소스코드를 실행파일이나 중간 코드로 변환하는 과정을 의미합니다.

### Java에서 컴파일 과정

![Java에서 컴파일 과정](http://tcpschool.com/lectures/img_java_programming.png)

1. 개발자가 .java 파일로 소스코드 작성
2. 컴파일러(javac)를 실행하면 .java 파일이 .class(바이트 코드) 파일로 변환
    - 바이트 코드는 JVM에서 실행 가능한 중간 코드입니다.
3. JVM이 바이트코드를 읽어 실행
4. JIT(Just-In-Time) 컴파일러가 바이트 코드를 기계어로 변환

### C/C++의 컴파일 과정

1. Preprocessing(전처리)
   - #include, #define 등의 전처리 명령 처리
2. Compilation(컴파일)
   - 소스코드를 어셈블리 코드로 변환
3. Assembly(어셈블)
   - 어셈블리 코드를 머신 코드(Object file)로 변환 
4. Linking(링킹)
   - 여러 객체 파일과 라이브러리를 결합하여 실행파일(.exe 등) 생성
   - 링크는 정적링크(컴파일, 빌드시)와 동적 링크(런타임)으로 구분됩니다.

이러한 과정을 표로 정리해 보자면 아래와 같습니다.

| 단계     | 입력                  | 주요 도구       | 출력                   | 핵심 역할                                  |
|----------|-----------------------|----------------|------------------------|--------------------------------------------|
| 전처리   | 소스코드(.c, .java)   | Preprocessor   | 확장된 소스(.i 등)     | 매크로, include, 조건부 처리               |
| 컴파일러 | 전처리 결과           | Compiler       | 어셈블리/오브젝트 코드 | 고급언어 → 저급언어(또는 중간코드)         |
| 어셈블러 | 어셈블리 코드 (.s)    | Assembler      | 오브젝트 코드 (.o, .obj)| 코드 → 기계어                              |
| 링커     | 오브젝트 파일         | Linker         | 실행 파일 (.exe, ELF)  | 다중 오브젝트 연결, 심볼 정리              |

이와 같은 과정을 통해서 프로그램이 컴파일 되며 프로세스로 할당되는지 알수 있습니다.

### Java vs C/C++ 컴파일 차이
| 구분        | Java                                    | C/C++                           |
|-------------|----------------------------------------|----------------------------------|
| 컴파일 결과 | 바이트코드(.class)                      | 기계어(Object file)              |
| 실행 환경   | JVM 위에서 실행 (플랫폼 독립적)          | OS/CPU 아키텍처에 종속적         |
| 장점        | 이식성 높음, 보안 기능 내장              | 실행 속도 빠름, 하드웨어 접근 용이 |
| 단점        | 실행 속도 느릴 수 있음                   | 플랫폼별로 재컴파일 필요          |

## Reference

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4
https://wonit.tistory.com/81
https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html