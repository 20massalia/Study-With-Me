# 이상 현상, 정규화, 반정규화

## 0) 한눈에 요약
- **이상 현상(Anomalies)**: 테이블 설계가 비정상적일 때 생기는 **삽입/갱신/삭제** 문제.
- **정규화(Normalization)**: 이상 현상을 없애고 **데이터 중복과 종속(중복)** 을 줄이는 구조화 규칙(1NF→2NF→3NF→BCNF…).
- **반정규화(Denormalization)**: 성능·편의 때문에 **일부 중복/결합**을 의도적으로 허용하는 설계.

---

## 1) 이상 현상(Anomalies)

하나의 테이블에 **서로 다른 주제의 속성**을 뒤섞거나, **중복**을 허용하면 발생.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F9ytyg%2Fbtr8T5eAhzB%2FAAAAAAAAAAAAAAAAAAAAAPEgOI2_dnK7f6NywRVqCsg4bCrl8t_ftCIHcjpR69f7%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DjRghcvj99eoJGoRCSxQz55Qa46A%253D)

- 새로운 직원이 추가되는 경우, 부서 정보가 없으면 부서코드를 임의 값으로 넣어야함
- 새로운 부서가 추가되는 경우, 사원 저옵가 없기 때문에 임의의 값으로 입력하거나, 추가할 수 없게됨.
- => 위 문제를 해결하기 위해서 정규화가 필요함

- **삽입 이상 (Insertion anomaly)**  
  새 상품을 등록하려면 주문이 있어야만 행을 넣을 수 있는 상황.
- **갱신 이상 (Update anomaly)**  
  고객 전화번호를 바꿀 때 여러 행을 모두 수정해야 하며 일부만 바꾸면 **불일치**.
- **삭제 이상 (Deletion anomaly)**  
  마지막 주문 행을 삭제했더니 **고객 정보까지 사라짐**.

> 예: `Order(order_id, order_date, customer_name, customer_phone, product_name, unit_price, qty)`  
> 같은 고객/상품 정보가 **여러 행에 중복**되어 있을 때 위 문제가 발생.
> 이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 합니다.

---

## 2) 정규화의 목표
- **중복 최소화**, **이상 현상 제거**, **데이터 일관성/무결성** 강화.
- 일반적으로 **3NF**(또는 **BCNF**)까지 적용하면 대부분의 이상 현상을 방지할 수 있음.

# 데이터베이스 정규화 (Normalization)

## 제 1 정규화 (1NF)
테이블의 컬럼이 **원자값(Atomic Value, 하나의 값)**을 갖도록 테이블을 분해하는 것.

**규칙**
- 각 컬럼이 하나의 속성만 가져야 한다.
- 하나의 컬럼은 같은 종류나 타입(Type)의 값을 가져야 한다.
- 각 컬럼이 유일한 이름을 가져야 한다.
- 칼럼의 순서는 상관없다.

**예시**  
변경 전:

| 이름   | 나이 | 수강과목   |
|--------|------|------------|
| 홍길동 | 20   | C, C++     |
| 이순신 | 21   | Java       |
| 이 산  | 22   | DB, 운영체제 |

변경 후:

| 이름   | 나이 | 수강과목   |
|--------|------|------------|
| 홍길동 | 20   | C          |
| 홍길동 | 20   | C++        |
| 이순신 | 21   | Java       |
| 이 산  | 22   | DB         |
| 이 산  | 22   | 운영체제   |

---

## 제 2 정규화 (2NF)
제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해.

**규칙**
- 제 1정규화를 만족해야 한다.
- 모든 컬럼이 부분적 종속(Partial Dependency)이 없어야 한다.  
  (모든 칼럼이 완전 함수 종속을 만족해야 함)

**예시**  
변경 전:

| 학생 이름 | 나이 | 수강과목   |
|-----------|------|------------|
| 홍길동    | 20   | C          |
| 홍길동    | 20   | C++        |
| 이순신    | 21   | Java       |
| 이 산     | 22   | DB         |
| 이 산     | 22   | 운영체제   |

변경 후:

**학생 테이블**

| 학생 이름 | 나이 |
|-----------|------|
| 홍길동    | 20   |
| 이순신    | 21   |
| 이 산     | 22   |

**수강 테이블**

| 학생 이름 | 수강과목   |
|-----------|------------|
| 홍길동    | C          |
| 홍길동    | C++        |
| 이순신    | Java       |
| 이 산     | DB         |
| 이 산     | 운영체제   |

---

## 제 3 정규화 (3NF)
제 2 정규화를 진행한 테이블에 대해 **이행적 종속(Transitive Dependency)**을 없애도록 분해.

**규칙**
- 제 2정규화를 만족해야 한다.
- 기본키를 제외한 속성들 간의 이행 종속성이 없어야 한다.

**예시**  
변경 전:

| 학생 코드 | 학생 이름 | DOB | Street | City | State | ZIP |
|-----------|-----------|-----|--------|------|-------|-----|

- `학생 코드`가 기본키 → 2NF 만족
- 하지만 `ZIP → Street, City, State` 종속 발생 → 중복 위험

변경 후:

**학생 테이블**

| 학생 코드 | 학생 이름 | DOB | ZIP |
|-----------|-----------|-----|-----|

**주소 테이블**

| ZIP | Street | City | State |
|-----|--------|------|-------|

---

## BCNF (Boyce-Codd Normal Form)
3차 정규화를 강화한 형태.  
**모든 결정자가 후보키 집합에 속해야 한다.**

**규칙**
- 제 3정규화를 만족해야 한다.
- 모든 결정자가 후보키 집합에 속해야 한다.

**예시**  
변경 전:

| 학생 | 과목  | 교수   | 학점 |
|------|-------|--------|------|
| 1    | AB123 | 김인영 | A    |
| 2    | CS123 | Mr.Sim | A    |
| 3    | CS123 | Mr.Sim | A    |

→ 교수와 과목 간 종속으로 데이터 중복, 갱신 이상 발생

변경 후:

**교수 테이블**

| 교수   | 과목  |
|--------|-------|
| 김인영 | AB123 |
| Mr.Sim | CS123 |

**수강 테이블**

| 학생 | 과목  | 학점 |
|------|-------|------|
| 1    | AB123 | A    |
| 2    | CS123 | A    |
| 3    | CS123 | A    |


---

## 3) 미니 정규화 예시

초기 테이블(중복/종속 多):
```
OrderLine(order_id, order_date, customer_id, customer_name, product_id, product_name, unit_price, qty)
```

정규화 후:
```
Customer(customer_id, customer_name)
Product(product_id, product_name, unit_price)
Order(order_id, order_date, customer_id)
OrderItem(order_id, product_id, qty)   -- PK: (order_id, product_id)
```
- 고객/상품 속성은 **자기 테이블**로 이동 → 중복 제거
- 주문-상품 수량은 **교차 엔터티**(`OrderItem`)로 모델링

---

## 4) 반정규화(Denormalization)

정규화는 이상 현상을 막지만, **조회 성능**이나 **단순화**가 필요할 때 반정규화를 검토.

### 언제 쓰나?
- 조인이 **너무 많아** 지연이 크고, **읽기 빈도 ≫ 쓰기 빈도**일 때
- 자주 쓰는 **집계/순위/상태**를 즉시 조회해야 할 때
- **커버링 인덱스**나 캐시로도 해결이 어렵거나 비용이 더 클 때

### 방법
- **속성 중복**: `Order`에 `customer_name`를 캐시(원장: Customer)  
- **프리조인 테이블(View/머티리얼라이즈드 뷰/스냅샷)**  
- **요약 테이블**: 일/월 단위 집계 테이블 사전 계산  
- **JSON/Array 칼럼**(관계형+도큐먼트 혼합; 변경/검증 전략 필요)

### 주의점(Trade-off)
- **쓰기 비용 증가**(여러 곳 동시 갱신), **일관성 위험**, **복잡한 보수 로직**  
- 반드시 **근거 있는 성능 지표**(P95 지연, QPS, CPU/IO)로 결정.

> 대안 먼저 검토: 적절한 **인덱스 설계**, **쿼리 튜닝**, **캐시(어플리케이션/Redis)**, **파티셔닝**.

---

## 5) 선택 가이드(체크리스트)

1. **3NF(또는 BCNF)까지 정규화**로 시작한다.  
2. 실제 트래픽 기반 **프로파일링**으로 병목을 확인한다.  
3. 인덱스/쿼리/캐시/파티셔닝으로 해결 가능한지 먼저 시도한다.  
4. 그래도 부족하면 **최소 범위**로 반정규화한다.  
5. 반정규화한 속성의 **원장(Truth Source)**과 **동기화 전략**(트리거/CDC/배치/이벤트)·**멱등성**을 정의한다.  
6. **모니터링/알림**으로 불일치와 지연을 추적한다.

---

## 6) 핵심 용어 요약
- **함수 종속**: X 값이 Y를 **결정**하면 `X → Y`.  
- **부분 종속**: 복합키의 **일부**로 Y가 결정.  
- **이행 종속**: X → Y, Y → Z이면 X → Z (X는 키, Y는 비키).  
- **결정자(Determinant)**: 종속을 **결정**하는 속성(집합).  
- **교차 엔터티**: N:M 관계를 풀기 위한 **중간 테이블**.

> 한 줄 요약: **정규화로 일관성을 확보하고, 증거가 있을 때만 최소한으로 반정규화**하자.