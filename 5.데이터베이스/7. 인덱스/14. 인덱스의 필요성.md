# 인덱스의 필요성

## 1. 인덱스

인덱스는 데이터베이스에서 쿼리 속도를 향상시키는 필수적인 자료구조입니다.
비유를 하자면, 책의 색인과 같습니다. 책에서 색인 없이는 원하는 정확한 정보를 찾기 어렵습니다.

데이터베이스에서 또한 마찬가지입니다. 테이블의 모든 데이터를 검색하려면 시간이 오래 걸리기 때문에 데이터와 데이터 위치를 포함한 자료구조를 생성하여 빠르게 조회하도록 돕습니다.

인덱스를 활용하면, 데이터를 조회하는 SELECT 쿼리 이외에도 UPDATE, DELETE의 성능이 함께 향상됩니다.
해당 연산을 수행하기 위해서는 대상을 조회하는 작업을 먼저 수행하기 때문입니다.

```mysql
UPDATE USER SET NAME = 'Byoungmin' WHERE NAME = 'Byoung';
```

위와 같은 연산을 수행하려면 컬럼의 데이터를 변경하기 앞서서 WHERE 문의 조건을 통해서 대상을 조회하게 됩니다.
즉, NAME이 'Byoung'인 대상을 먼저 찾게 됩니다.

## 2. 인덱스가 없으면 무슨일이 일어날까?

인덱스가 없으면 어떤 일이 일어날까요? 자료의 위치를 찾게 도와주는 지표가 사라졌기 때문에 이때 DBMS는 테이블 전체의 데이터를 읽게됩니다.

이를 **Full Scan**이라고 합니다.

만약에 인덱스를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 테이블 전체를 탐색하는 Full Scan을 수행하게 됩니다.
Full Scan은 전체를 비교해서 탐색하기 때문에 처리 속도가 현저히 떨어집니다. 하지만 이러한 인덱스는 장점만 있는 것이 아닙니다.

## 3. 인덱스의 장점과 단점

### 장점

- 검색 속도가 월등히 빨라집니다. (정렬, 집계, WHERE, JOIN 모두..)
- 데이터 무결성을 보장합니다. (UNIQUE, PRIMARY KEY 등 제약 조건에 필수적입니다.)

### 단점

- 데이터의 변경이 잦을수록 인덱스의 유지비용이 높아짐(DML 사용시 인덱스도 갱신됩니다.)
- 저장 공간 소모(복합 인덱스, 비트맵 인덱스 등..)
- 인덱스를 너무 많이 만들면 오히려 성능 저하(불필요한 인덱스가 갱신, 조각화되며 오버헤드가 생깁니다.)

> 부등호, LIKE 조건에서 인덱스가 항상 적용되는 것은 아닙니다.
> + 해시 인덱스는 부등호 연산이나 패턴 매칭에 사용되지 않습니다.  

### 인덱스의 방향

추가적으로 인덱스에는 방향이라는 개념이 있습니다. 
옵티마이저가 최적화 하여 순서를 정해주지만 정순으로 인덱스를 읽는것이 역순보다 빠릅니다.
더 자세한 내용은 아래의 카카오 테크의 블로그 글에서 찾아볼 수 있습니다.

[Tech Kakao - MySQL Ascending index vs Descending index](https://tech.kakao.com/posts/351)

## 3. 인덱스 자료구조의 종류

이제 인덱스의 필요성과 장단점에 대해서 알아보았습니다. 다음으로는 인덱스의 종류에 대해서 살펴보겠습니다.

이러한 구분 방식 말고도 데이터 저장 방식에 따라서 클러스터드 인덱스와 넌클러스티드 인덱스로 나누기도 합니다.
그러한 차이점은 추후에 알아봅시다.

### B-Tree 인덱스

B-Tree는 자식 2개 만을 갖는 이진 트리를 확장해서 N개의 자식을 가질 수 있도록 고안된 자료구조입니다.

이 자료구조는 최상위의 하나의 루트 노드를 가집니다. 그리고 중간에 브랜치 노드, 최하위의 노드를 리프 노드라고 합니다.

![B-Tree 인덱스](https://blog.kakaocdn.net/dna/djhlni/btrXnJAFNh0/AAAAAAAAAAAAAAAAAAAAAKSjTmRIzxVIaSMDmGfav6lRDKGejU2XR615TFO3nDZ5/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=dv%2B%2FJJkepUDLQa%2BUOUeyI3yFS1g%3D)

먼저 인덱스의 저장 방식을 이해하기 위해서는 페이지(블럭)에 대해서 추가로 설명할 필요가 있습니다. 

페이지란 디스크와 메모리에서 데이터를 처리하는 최소 단위입니다. 일반적인 인덱스를 포함한 PK(클러스터 인덱스)와 테이블은 모두 페이지 단위로 관리됩니다.
따라서 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 블록을 읽어야 하는 것입니다.

그래서 페이지에 저장되는 개별 레코드 데이터의 크기를 최대한 작게하여 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 중요합니다.
페이지에 저장되는 데이터의 크기가 크면 아래와 같은 문제가 발생할 수 있습니다.

- 디스크 I/O 증가
- 메모리 캐싱 페이지 수 감소

B-Tree의 노드에서는 (인덱스, PK) 쌍으로 저장합니다. 즉, 인덱스를 통해서 PK 값을 찾고, PK 값을 통해 정확한 레코드를 찾는 것입니다.
이러한 두 가지의 작업을 수행을 통해서 인덱스로 데이터를 조회하는 것입니다.

이러한 두 가지 작업을 수행하기 때문에 테이블을 직접 읽는 방법보다 비용이 더 발생합니다. 하지만, DBMS에서 테이블을 직접 읽어 모든 테이블을 읽기에는 엄청난 리소스 소모가 발생하게 됩니다.
그렇기 때문에 인덱스를 사용해 레코드를 찾는 속도가 훨씬 빠릅니다. 반대로 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적입니다.
이런 경우에는 옵티마이저가 인덱스를 활용하지 않고 테이블 전체를 읽어서 처리합니다.

### B+Tree 인덱스

B+Tree는 B-Tree와 비슷하지만 개선점이 있습니다. 바로 리프 노드끼리 서로 연결리스트로 연결되어 있다는 점입니다.

이러한 특징을 통해서 B-Tree 보다 쉽게 범위 탐색이 가능합니다.

![B+Tree](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FlmNml%2FbtrhSZR4BuI%2FAAAAAAAAAAAAAAAAAAAAAJ52OYh7p9Ib3J7Xd4KxFH5FdYJSzlqf7CXU7JDFSYjX%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DuvshUJjwBo9zRExrjAV9gHwklOk%253D)

예시로 100~200 번 사이의 데이터를 조회한다고 하면, 100번 데이터를 조회한 이후에 연결된 리스트를 따라가면 순차적인 범위 탐색이 보다 쉽게 가능합니다.
정리해보자면 5가지의 개선된 모습이 있습니다.

- 검색 방법: 중간 노드에는 키만 저장되고, 리프 노드에 키와 값이 저장
- 포인터의 사용: 리프노드 끼리 연결리스트로 연결
- 범위 쿼리와 범위 검색: 리프노드만 따라가면 범위 검색 가능
- 순차 탐색 및 정렬: 연결된 리스트이기에 키들이 항상 정렬
- 메모리 사용: 데이터는 단말 노드에만 저장됨으로 메모리 효율이 좋음

### 해시 인덱스

해시 인덱스(Hash Table)는 키 값을 통해 고유한 인덱스를 생성해서 해당하는 값을 가져오는 자료구조입니다. 

해시 함수의 특성 때문에 해시 인덱스가 사용되는 경우는 부등호 연산이 많은 경우입니다. 다른 부등호 연산(범위 탐색)이 많은 데이터인 경우에는 해시 인덱스가 적합하지 않습니다.

InnoDB에서는 버퍼 풀에서 빠른 레코드 검색을 위해 적응형 해시 인덱스(Adaptive Hash Index)를 사용하기도 합니다.
또한, Oracle에서는 JOIN시에 활용되기도 합니다.

아래와 같은 쿼리들이 해시 인덱스를 사용하며 장점을 활용할 수 있는 쿼리 예시입니다.

```mysql
SELECT .. FROM tb_hash WHERE column = '검색어';
SELECT .. FROM tb_hash WHERE column <=> '검색어'; # null safe equal
SELECT .. FROM tb_hash WHERE column IN ('검색어', '검색어');
SELECT .. FROM tb_hash WHERE column IS NULL;
SELECT .. FROM tb_hash WHERE column IS NOT NULL;
```

아래는 해시 인덱스를 활용하지 못하는 쿼리입니다. 위에서 설명한 것처럼 범위 검색에는 사용할 수 없는 것을 알 수 있습니다.

```mysql
SELECT .. FROM tb_hash WHERE column >= '검색어';
SELECT .. FROM tb_hash WHERE column BETWEEN 100 AND 120;
SELECT .. FROM tb_hash WHERE column LIKE '검색어%'
SELECT .. FROM tb_hash WHERE column <> '검색어';
```

### 비트맵 인덱스

비트맵 인덱스는 인덱스 컬럼의 데이터를 비트 값인 0, 1로 변환하여 인덱스 키로 사용하는 방법입니다.

B-Tree 인덱스와 달리 카디널리티 값이 낮은 경우(데이터의 중복도가 높은 경우)에 사용하기 좋습니다.
아래의 색상표에 대한 비트맵 인덱스에 대한 적용을 예시로 볼 수 있습니다.

![비트맵 인덱스](https://velog.velcdn.com/images/gayeong39/post/677f575a-00f0-422d-9525-44faf2287229/image.png)

분포도가 낮은 컬럼에 적합하며 성능 향상 효과를 얻을 수 있습니다. 
다른 인덱스에 비해 저장 공간이 적어 효율이 좋고, 다중 조건을 만족하는 쿼리에 적합합니다.

예시로 성별(M, F)과 업무 형태(자택, 출퇴근)과 같은 다른 정보를 여러개 갖는 조건 쿼리에 적합합니다.

### 역 인덱스(Inverted Index)

역 인덱스는 텍스트 데이터의 검색(검색엔진, 로그분석)에 특화된 인덱스입니다. 키워드를 통해 문서를 찾는 방식인데요.

예시를 들어보자면 책의 뒷편에 있는 색인을 살펴봐 키워드를 통해 페이지를 찾는 과정입니다.
일반적인 탐색은 키워드를 찾기 위해서 모든 데이터를 조회해야 합니다. 
하지만 역 인덱스의 경우에는 해당 키워드를 가진 주소 값만 읽으면 되기 때문에 속도가 빠릅니다.

아래에서 색인과 역색인의 차이를 그림을 통해 보겠습니다.

![색인 탐색](https://velog.velcdn.com/images/tjseocld/post/4bb58e2e-d268-4c08-ae6f-c8b1b80ac41e/image.png)

위의 그림을 보면 'fox' 라는 키워드를 검색할 때 모든 텍스트를 읽어야합니다. 따라서 많은 데이터를 검색할 경우 그만큼 성능이 저하될 수 있습니다.

RDBMS 에서는 Like 키워드를 사용하여 검색을 할 때 사용되며 데이터가 많아질수록 검색 성능이 떨어질 수 있습니다.

![역색인 탐색](https://velog.velcdn.com/images/tjseocld/post/a92dc1d3-e0a5-43d6-9330-b00a9a1195a5/image.png)

역색인은 책 뒤에 찾아보기와 같이 해당 Term (키워드) 에 해당하는 주소값만 읽으면 되기 때문에 속도가 빠릅니다.
역색인을 사용하면 데이터가 추가되어도 조회해야 하는 행이 늘어나느 것이 아니라 역색인이 가리키는 Term 의 ID(PK, 주소) 배열 값에 ID가 추가되는 것이기 때문에 성능에 큰 문제가 되지 않습니다.

## Reference

https://mangkyu.tistory.com/96
https://bcp0109.tistory.com/365
https://mangkyu.tistory.com/286
https://velog.io/@jsj3282/17.-%ED%95%B4%EC%8B%9CHash-%EC%9D%B8%EB%8D%B1%EC%8A%A4
https://velog.io/@gayeong39/%EB%B9%84%ED%8A%B8%EB%A7%B5-%EC%9D%B8%EB%8D%B1%EC%8A%A4BitMap-Index
https://velog.io/@tjseocld/Database-%EC%97%AD%EC%83%89%EC%9D%B8-Inverted-Index
