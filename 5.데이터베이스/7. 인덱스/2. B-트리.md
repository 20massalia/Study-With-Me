# ✅ B-TREE (Balanced Tree)

## 📌 개요

B-Tree는 이진트리를 확장한 트리로, 하나의 노드가 가질 수 있는 자식
노드의 개수가 **2개 이상**일 수 있는 트리 구조이다.

B-Tree는 **균형트리(Balanced Tree)** 로서, 모든 리프노드가 같은 depth를
갖도록 설계되어 있다.\
따라서 검색에 걸리는 시간이 일정하다.

------------------------------------------------------------------------

## 📖 특징

-   하나의 노드에 여러 개의 값을 가질 수 있다.\
-   이진트리는 최대 자식이 2개이지만, **B-Tree는 자식 노드가 여러 개
    존재**할 수 있다.

------------------------------------------------------------------------

## ⏺ 시간복잡도와 B-Tree의 규칙

-   일반 트리에서 최악의 경우(편향된 트리): **O(N)**\
-   B-Tree는 균형을 유지하여 최악의 경우에도 **O(logN)** 이 보장된다.

### 규칙

1.  노드의 key의 수가 k개라면, 자식 노드의 수는 **k+1개**이다.\
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FQjG5H%2FbtrBgpDJkg7%2FAAAAAAAAAAAAAAAAAAAAAOVnYLFyIT3AB23WtU9lZhkCGBc6NrtaZFxaHuLQCUim%2Fimg.webp%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DBatQaHV2oOftEMBSL56ZmCGvLH0%253D)

2.  노드의 key는 반드시 **정렬된 상태**여야 한다.\
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FtxFtg%2FbtrBfY0XYJQ%2FAAAAAAAAAAAAAAAAAAAAABMV8FCwY368B2Piu1F8pBIiw4yGbNYSGzsn9exSK8tp%2Fimg.webp%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DIB%252FzgNi2jbMQsXBZ%252BHXjXdyxfQ4%253D)

3.  자식 노드들의 key는 현재 노드의 key를 기준으로 크기 순으로 나뉜다.\
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FJOl2D%2FbtrBfFAuAgh%2FAAAAAAAAAAAAAAAAAAAAAOFQMy-V-3QdIp7p9deUMprgaouvbnbpYv0eorarXQf3%2Fimg.webp%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DYUUzJu8lZ9gTNlhQK2FZWrF80Xc%253D)

4.  Root 노드는 항상 **2개 이상의 자식 노드**를 갖는다. (Root 노드가 Leaf인 경우 제외)\


5.  M차 트리일 때, Root와 Leaf를 제외한 모든 노드는 최소 ⌈M/2⌉, 최대 M개의 서브 트리를 갖는다.\


6.  모든 Leaf 노드들은 같은 level에 있어야 한다.\
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FBVE0C%2FbtrBfY05W5E%2FAAAAAAAAAAAAAAAAAAAAAKcvmqCyhTezGVXfVgZ2-A3BCuf4SG4q6YA7AOUdJ8zH%2Fimg.webp%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3D4DBkRsjneoBC1dGD5UWEvK8xRmQ%253D)

------------------------------------------------------------------------

## ⏺ 노드 종류

-   **Root Node**: 최상단 노드\
-   **Leaf Node**: 자식이 없는 최하단 노드\
-   **Internal Node**: Root와 Leaf를 제외한 모든 노드

------------------------------------------------------------------------

## ✍️ 검색 (Search)

1.  Root 노드에서 시작하여 검색하려는 값과 노드의 값을 비교한다.\
2.  검색 값이 노드의 값보다 작으면 **왼쪽 자식**으로 이동한다.\
3.  검색 값이 노드의 값보다 크면 **오른쪽 자식**으로 이동한다.\
4.  이를 반복하며 검색값을 가진 노드를 발견하면 종료한다.

------------------------------------------------------------------------

## ✍️ 삽입 (Insertion)

1.  Root에서 시작하여 삽입하려는 값과 노드의 값을 비교한다.\
2.  삽입 값이 노드의 값보다 작으면 **왼쪽 자식**으로 이동한다.\
3.  삽입 값이 노드의 값보다 크면 **오른쪽 자식**으로 이동한다.\
4.  삽입할 위치의 노드가 가득 차 있다면 **노드를 분할**한다.

### 분할 규칙

1.  **가운데 값**을 선택한다.\
2.  가운데 값을 기준으로
    -   작은 값들은 **왼쪽 노드**\
    -   큰 값들은 **오른쪽 노드**에 넣는다.\
3.  가운데 값은 부모 노드로 올린다.\
4.  부모 노드가 가득 차면 같은 방식으로 반복한다.
    -   이 과정에서 Root 노드가 분할되면 새로운 Root가 생성되고, 트리의
        높이가 1 증가한다.

------------------------------------------------------------------------

Reference
- https://code-lab1.tistory.com/217