# Clustered Index, Non-Clustered Index

클러스터드 인덱스와, 넌-클러스터드 인덱스는 인덱스를 나누는 가장 큰 방식입니다. 실제 데이터 저장 구조와 페이지 동작, 목적에 따라서 차이가 있습니다.

![Clustered Index](https://blog.kakaocdn.net/dna/LAP9y/btrqOg4Jijm/AAAAAAAAAAAAAAAAAAAAAHgiQSXa4iiVxr3zNjoCOHf6BKSL1yA3kj_ym8po-qhZ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1759244399&allow_ip=&allow_referer=&signature=jVJ8AkjEbFZUew8o1MuLfb4GNKw%3D)

## Clustered Index

클러스터드 인덱스는 지정된 컬럼을 기준으로 테이블의 실제 데이터가 물리적으로 정렬되는 인덱스입니다.
주로 PK로 자동생됩니다.

테이블의 레코드들은 인덱스 키 값 순서대로 저장됩니다. 즉, 인덱스를 구성한 컬럼 값이 오름차순 또는 내림차순으로 실제 데이터가 정렬되어 저장됨으로 테이블 자체가 인덱스가 됩니다.

![Clustered Index](https://cdn.sanity.io/images/oaglaatp/production/6366923af7606472b084668ba805df3b1300a990-6511x2392.jpg?rect=0,1,6511,2391&w=1920&h=705&auto=format)


특징은 아래와 같습니다.

- 한 테이블의 하나만 생성 가능 (주로 PK)
- 범위 검색, 정렬 쿼리에 유리 (WHERE, ORDER BY, BETWEEN)
- 테이버 삽입/수정/삭제 시 정렬을 다시 해야 함으로, 쓰기 성능 비용이 높습니다.
- 별도 인덱스 공간이 필요없고, 테이블 자체가 정렬 기준이됩니다.

### 왜 우리는 id를 PK로 설정하고 auto_increment 옵션을 설정할까?

varchar의 email에 pk를 설정했다고 가정해봅시다.

이때 'a'로 시작하는 이메일을 사진 유저를 추가하게 되면, 해당 이메일 보다 사전상 뒤에 나오는 레코드 들은 한 칸씩 이동하며 수정해야합니다.
이러한 과정은 대용량 테이블에서 성능 저하를 일으킵니다. 따라서 우리는 pk id에 auto_increment 옵션을 주는 것입니다.

## Non-Clustered Index

넌-클러스터드 인덱스는 테이블 자체의 물리적 순서와 별도로 별도의 인덱스를 말합니다.

다양한 자료구조(B+Tree, Hash, Bitmap) 등을 사용하며, 인덱스 페이지에 정렬된 키 값과 해당 데이터 위치를 가르키는 포인터(ROWID)가 저장됩니다.
ROWID는 레코드 값을 가리키는 포인터 값을 포함합니다. (대표적으로 PK)

![Non-Clustered Index](https://cdn.sanity.io/images/oaglaatp/production/afb2e2a9fcea750d576173172f05f071b4e3d763-6366x2823.jpg?rect=0,1,6366,2822&w=1920&h=851&auto=format)

특징은 아래와 같습니다.

- 한 테이블에 여러 개 생성 가능
- 테이블의 물리적 순서는 바꾸지 않음으로 쓰기 성능에 영향이 적습니다.
- 인덱스 페이지를 별도로 관리하기 때문에 별도의 저장공간이 필요합니다. (약 10%)
- 검색 시 인덱스 -> 레코드 데이터로 두 번 접근하는 방식이기 때문에 클러스터드 인덱스만 사용한 것에 대비해 느립니다.

## Reference

https://choiblack.tistory.com/53
https://www.stratascratch.com/blog/clustered-vs-non-clustered-indexes-in-sql/

