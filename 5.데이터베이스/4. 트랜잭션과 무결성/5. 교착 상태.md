# DB 교착 상태 (Dead Lock)

## 1. 교착 상태란?
데이터베이스에서 교착 상태는 여러 개의 트랜잭션들이 실행하지 못하고 서로 무한정 기다리는 상태를 말한다.  
즉, 두 개 이상의 트랜잭션이 특정 자원의 lock을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태이다.

➕ 운영체제에서의 교착 상태는 각각의 프로세스가 서로의 자원을 점유하기 위해 대기하면서 생기는 문제를 말한다.

---

## 2. 교착상태가 일어나는 상황
예시:
- 트랜잭션 1이 테이블 B에 INSERT를 수행
- 트랜잭션 2가 테이블 A에 INSERT를 수행
- 이후 서로가 lock을 건 행에 INSERT 작업을 시도

→ 두 개의 트랜잭션 모두 waiting이 발생하고 교착상태(Dead Lock)에 빠지게 된다.

---

## 3. 교착 상태 해결 방법
- 예방 기법
- 회피 기법
- 낙관적 병행 제어 기법
- 빈도 줄이기 기법

---

### 3.1 예방 기법
- 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 lock 한다.  
  → 필요한 모든 데이터를 lock 해야하므로 병행성이 떨어진다.
- `SET LOCK_TIMEOUT` 문을 통해 일정 시간이 지나면 쿼리를 취소한다.
- 기존의 교착상태인 데이터가 있다면, 그 데이터에 접근하는 쿼리만 취소한다.  
  → 근본적인 해결책이 될 수 없다.

---

### 3.2 회피 기법
- 자원을 할당할 때 **시간 스탬프(Time Stamp)**를 활용하여 교착상태가 일어나지 않도록 회피한다.
- 예방 기법의 단점 때문에 실제로는 회피 기법이 많이 사용된다.

#### Wait-Die 방식

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbDs0Ch%2FbtsDFXcLFJT%2FAAAAAAAAAAAAAAAAAAAAAD68bbcZMXYA8eg6lb7mBd9RhcWczq1edXzrgLMzr9-3%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3Dp2HVrtpqSlnYQgHdlM%252FzIFKSWBA%253D)

- 트랜잭션 1이 트랜잭션 2에 의해 잠금된 데이터를 요청할 때:
    - 트랜잭션 1이 먼저 들어온 트랜잭션이라면 **대기(wait)**한다.
    - 트랜잭션 1이 나중에 들어온 트랜잭션이라면 **포기(die)**하고 나중에 다시 요청한다.

#### Wound-Wait 방식

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fdzigze%2FbtsDAGRooBc%2FAAAAAAAAAAAAAAAAAAAAAImxfOYy5hZzuiMlfOJyEV-VAOGdcDNxUvhizqyJKh3s%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3DmMqc2mYRnN16CERaW08aT70VbpI%253D)

- 트랜잭션 1이 트랜잭션 2보다 먼저 들어온 경우 → 데이터를 **선점(wound)** 한다.
- 트랜잭션 1이 트랜잭션 2보다 나중에 들어온 경우 → **대기(wait)** 한다.

---

### 3.3 낙관적 동시성 제어 (Optimistic Concurrency Control, OCC)

## 개념
- 자원에 Lock을 걸어 선점하지 않고, **동시성 문제가 발생했을 때 처리하는 방법론**
- 사용자가 동시에 데이터를 수정하지 않을 것이라고 **가정(낙관)** 하고 처리
- 트랜잭션 충돌을 막지 않고, **충돌 발생 시점에 감지하여 처리**
- 데이터를 읽을 때는 Lock을 설정하지 않음
- 데이터를 수정하려는 시점에 **읽은 데이터가 다른 사용자에 의해 변경되었는지 검사** 필요

## 충돌 감지 방식
- 일반적으로 **버전(version) 값**을 비교
- 또는 **해시 코드(hashcode)**, **타임스탬프(timestamp)** 등을 이용해 변경 여부 확인
- 충돌이 확인되면 → **롤백 처리**

## 특징
- 동시성 제어를 **DB 단이 아닌 애플리케이션 단에서 처리**
- 여러 작업이 묶인 트랜잭션 요청이 실패하면 → **개발자가 직접 롤백 처리** 해주어야 함

## 장점
- 충돌이 거의 발생하지 않는 경우, **동시 요청에 대해 성능이 좋음**
- Lock을 사용하지 않으므로 **데드락(Deadlock) 우려 없음**

## 단점
- 충돌이 잦을 경우, **롤백 처리 비용이 커져 성능 저하** 발생
- 롤백 처리를 직접 구현해야 하므로 **구현 복잡도 증가**

---

### 3.4 빈도 줄이기 기법
- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다.
- 읽기 잠금 (`SELECT ~ FOR UPDATE`)의 사용을 피한다.
- 테이블 단위의 lock을 획득해 갱신을 직렬화 한다.  
  (한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착 상태가 자주 발생한다.  
  테이블 단위의 잠금을 획득해 직렬화하면 동시성은 떨어지지만 교착 상태를 피할 수 있다.)

---

Reference
- https://dahliachoi.tistory.com/93