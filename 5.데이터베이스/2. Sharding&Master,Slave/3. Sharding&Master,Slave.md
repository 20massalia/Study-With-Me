# Sharding & Master/Slave

## 1. Sharding - 샤딩

샤딩은 데이터를 여러 DB에 분산하여 저장하는 방식입니다. 또한, 데이터베이스의 확장성을 높이는 방법으로 수평적 스케일링 방법입니다.

![Sharding](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbX7FIw%2FbtsF2EouMue%2FAAAAAAAAAAAAAAAAAAAAAM6MlKH3Op_vIa3C388zJBSoGb5aP5u0RpzAZUYHaYYs%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DjuA7UdLPJetJ064exXnq4cVTVuE%253D)

- 데이터를 특정 Hash Function을 통해 구분지어 각 샤드에 저장합니다.
- 클라이언트는 각 요청에 대해 Hash Function을 통해 데이터가 있는 샤드에 접근하여 데이터를 조회 및 저장합니다.
- 각 샤드에는 장애 시 메인 샤드 DB로 승격될 수 있는 백업을 가질 수 있습니다.
- 이를 통해 새로운 DB를 계속 추가함으로써 무한히 확장 가능합니다. (수평 스케일링의 장점)

아래와 같은 모듈러 샤딩과 레인지 샤딩을 알아보겠습니다.

### 요구사항

모듈러샤딩과 레인지샤딩의 공통된 요구사항은 아래와 같습니다.

- 라우팅을 위해 구분할 수 있는 유일한 키값이 있어야 한다.(편의상 아래부터는 PK 또는 샤딩키라고 부릅니다.)
- 올바른 DB를 찾을 수 있도록 라우팅이 돼야 한다.
- 설정으로 쉽게 증설이 가능해야 한다.

### 1. Modular Sharding

![Modular Sharding](https://techblog.woowahan.com/wp-content/uploads/img/2020-07-06/thiiing-db-modular-sharding.png)

모듈러샤딩은 PK를 모듈러 연산한 결과로 DB를 특정하는 방식입니다. 간략한 장단점은 아래와 같습니다.

- 장점: 레인지샤딩에 비해 데이터가 균일하게 분산됩니다.
- 단점: DB를 추가 증설하는 과정에서 이미 적재된 데이터의 재정렬이 필요합니다.

모듈러샤딩은 데이터량이 일정 수준에서 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 어울리는 방식입니다.

물론 데이터가 꾸준히 늘어날 수 있는 경우라도 적재속도가 그리 빠르지 않다면 모듈러방식을 통해 분산처리하는 것도 고려해볼 법 합니다.
무엇보다 데이터가 균일하게 분산된다는 점은 트래픽을 안정적으로 소화하면서도 DB리소스를 최대한 활용할 수 있는 방법이기 때문입니다.

### 2. Range sharding

![Range sharding](https://techblog.woowahan.com/wp-content/uploads/img/2020-07-06/thiiing-db-range-sharding.png)

레인지샤딩은 PK의 범위를 기준으로 DB를 특정하는 방식입니다. 간략한 장단점은 아래와 같습니다.

- 장점: 모듈러샤딩에 비해 기본적으로 증설에 재정렬 비용이 들지 않습니다.
- 단점: 일부 DB에 데이터가 몰릴 수 있습니다.
- 
레인지샤딩의 가장 큰 장점은 증설작업에 드는 비용이 크지 않다는 점입니다. 데이터가 급격히 증가할 여지가 있다면 레인지방식도 좋은 선택일겁니다.
다만 단점을 무시할 수 없는데요. 주로 활성유저가 몰린 DB로 트래픽이나 데이터량이 몰릴 수 있기 때문입니다.
기껏 분산처리를 했는데 이런 상황이 발생하면 또다시 부하분산을 위해 해당 DB를 쪼개 재정렬하는 작업이 필요하고, 반대로 트래픽이 저조한 DB는 통합작업을 통해 유지비용을 아끼도록 관리해야 합니다.

이러한 두가지 방법 이외에도 다양한 방법이 있습니다. 각 장단점을 고려하여 상황에 맞게 도입할 수 있습니다.

위에서는 RDBMS에서 일반적인 샤딩 방식에 대해서 살펴봤습니다. 다음으로는 다른 NoSQL의 샤딩 방식에 대해서 살펴보겠습니다.

### MongoDB Sharding 

![Sharding-MongoDB](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FyXoEu%2FbtsF0sQD4pa%2FAAAAAAAAAAAAAAAAAAAAAChhUlQbishBgtRK5Rj5BKRxRv0Yn0NvzxaSgz_ttibw%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DZ2%252BXVeuKdmGaFFG57oFHJJCohKA%253D)

- 최소 3대 이상의 호스트를 구성하여 하나의 호스트에 장애가 발생해도 다른 호스트로 즉시 복구 될 수 있도록 한다. (고가용성)
- 또한 3대 이상의 RS(Replica Set, = 샤드)을 두어 데이터를 분산저장한다. (해당 예시에서는 userId를 기준으로 분산)
- 각 RS에는 Secondary DB들을 두어 Primary DB에 장애가 발생해도 Secondary DB를 Primary로 승격시켜 즉시 복구 될 수 있도록 한다. (고가용성)
- 각 데이터의 분산 정보는 구성서버 (Config Server)에 기록해두어 mongos가 구성서버에서 데이터를 찾아올 위치를 알아와 처리한다.
- 각 RS는 주기적으로 OPLog(데이터의 변경사항에 대한 쿼리가 저장되는 별도의 저장영역)에서 로그를 폴링하며 데이터를 동기화한다.

위와 같은 다양한 단계의 샤딩을 통해서 고가용성을 보장하고 단일 장애점을 최소화합니다.
하지만 장애 대비 많은 ReplicaSet이 대기하고 있어서 DB 구성시 비용이 높고, 유지보수 비용 또한 높습니다.

### RDB vs NoSQL

이러한 샤딩 데이터베이스는 일반적으로 NoSQL (Not Only SQL)DB 입니다. RDB의 경우, 스키마가 고정되어 있고 정규화를 통한 join 연산을 통해 연관된 데이터를 가져옵니다.
물리적으로 분할된 샤드에서의 join 연산은 많은 어려움이 동반되므로 샤딩은 고정되지 않은 스키마와 정규화되지 않은 데이터가 저장되는 NoSQL DB에서 주로 사용합니다.

더 많은 샤드가 추가될 때 데이터를 다시 분배하는 방식(Resharding)에 대한 처리가 까다롭고, 특정 데이터에 대한 요청이 몰릴 경우 해당 샤드에 트래픽이 몰리는 HotSpot 문제가 있을 수 있습니다.
모니터링을 통해 트래픽을 파악하고 샤드를 재분배하는 방식으로 해결해야 합니다.

NoSQL은 비정규화를 통해 다른 테이블에서 데이터를 결합해 가져오는 join 연산 없이 데이터를 key-value 형식 등으로 바로 가져올 수 있고, 샤딩을 통해 데이터를 수평적으로 확장할 수 있습니다.
그러나 데이터 변경 시 중복된 모든 데이터를 모두 변경해야 하는 단점이 있습니다.

RDB는 정규화를 통해 중복된 데이터를 별도 테이블에 두어 공간을 절약하고, 변경 시 해당 데이터만을 수정하면 되는 용이성이 있습니다.
그러나 데이터 조회 시 연관된 데이터를 조회하기 위해 join 연산이 필요합니다.
데이터의 변경이 잦은지 / 많은 데이터가 저장되어 확장이 고려되는지 / 다른 테이블과 join 연산 시 병목이 치명적인지 등을 고려하여 RDB, NoSQL의 사용을 고려해야합니다.

#### 정리

- 데이터베이스를 수평적으로 확장하는 방식에는 데이터를 여러 DB에 분산하여 저장하는 샤딩(Sharding) 방식이 있다.
- 데이터 조회 및 저장 시 여러 DB가 트래픽을 분산하여 처리하고 장애 발생 시 다른 Secondary DB가 Primary DB로 승격해 처리한다.
  - 트래픽 분산이 용이하고 가용성이 높다.
- 하지만 그에 따라 동기화의 문제, 많은 DB 구성으로 인한 비용, 유지보수의 어려움이 존재한다.
- RDB와 NoSQL은 데이터의 변경, 확장성, join 연산 시 병목 등에서 각 차이를 보이므로 이러한 조건을 파악하여 선택하는 것이 중요하다.

## 파티셔닝과의 차이

파티셔닝 방식은 수평/수직 분할 방식이며 키를 사용하지 않습니다. 또한 궁극적으로 분할 데이터를 동일한 서버에 저장합니다.
따라서 하드웨어 및 성능 향상을 고려하여 두 방식을 고려해 적용해야 합니다.

![파티셔닝](https://velog.velcdn.com/images/msung99/post/c2c056e4-665d-42f0-aa58-0a025ae1fb0c/image.png)

위의 그림을 통해서 간락히 샤딩과 파티셔닝의 차이에 대해서 살펴볼 수 있습니다.

## DB Master/Slave

마스터와 슬레이브는 샤딩과 같이 DB의 가용성을 높이기 위한 방법입니다.

- Master: 메인이 되는 작업을 수행하는 데이터베이스(insert, update, delete)와 같은 DML 작업을 수행합니다.
- Slave: 마스터 데이터 베이스를 복제하는 곳으로 DB를 복사하고 유지합니다. 주로 select 작업 실행.

이러한 마스터 슬레이브의 복제 매커니즘에 대해서 살펴보겠습니다.

![Master/Slave-1](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FWfPlD%2FbtranF75XQp%2FAAAAAAAAAAAAAAAAAAAAAEP8_lMCNP0DvddOeGkzj2Hsu4uWesFzTJ-OVR1i2mau%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DYgmFTPLN6VQo012KUqtc%252Ba0WqQk%253D)

Master에게는 데이터 동시성이 아주 높게 요구되는 트랜잭션을 담당하고, Slave에게는 읽기만 데이터 동시성이 꼭 보장될 필요는 없는 경우에 읽기 전용으로 데이터를 가져오게 됩니다.

![Master/Slave-2](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FG2cIO%2FbtrapFNGsO3%2FAAAAAAAAAAAAAAAAAAAAAFE2gw9O2QN7nyFe_9lt36EPpSu0MJo5NbJ4jNvQcVSF%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DBNqIkzFqt6qMQVqAE32DpOMAmqc%253D)

일반적으로 Front에서 데이터를 읽어들일 때, 꼭 데이터 일관성이 필요한 경우와 아닌 경우에 대한 API가 나누어지게 됩니다.

그런 경우에 읽기전용으로 트랜잭션을 사용하여 디비에 대한 트래픽을 분산시킬 수 있습니다.

## Reference

https://hungseong.tistory.com/118
https://techblog.woowahan.com/2687/
