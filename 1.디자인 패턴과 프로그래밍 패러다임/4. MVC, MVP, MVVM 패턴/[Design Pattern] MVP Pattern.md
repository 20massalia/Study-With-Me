# MVP 패턴

> 뷰와 모델 간 상호작용을 프리젠터에게 맡김으로써 서로의 의존성을 최소화하는 패턴

MVP(모델-뷰-프리젠터)는 MVC와 달리 컨트롤러 대신 프리젠터가 존재합니다. 모델과 뷰의 결합도를 낮춰 새로운 기능 추가에 대한 어려움을 줄이고 확장성을 높입니다. 또한, UI와 데이터 각각의 역할이 명확해집니다.

<br/>

## 구성 요소

- **모델**: 애플리케이션의 핵심 데이터와 비즈니스 로직을 나타냅니다.
  - 데이터 저장소와의 상호 작용, 데이터 처리 및 유효성 검사와 같은 작업을 수행합니다.
  - 모델은 독립적으로 작동하며, 뷰와 컨트롤러와 직접적으로 통신하지 않습니다.
- **뷰**: 사용자에게 보여지는 애플리케이션의 UI로, 레이아웃과 화면을 처리합니다.
  - 프리젠터에서 데이터를 받아 사용자에게 표시합니다.
  - 사용자의 입력은 프리젠터에 의해 처리되도록 설계되어야 합니다.
- **프리젠터**: 모델과 뷰 사이 매개체입니다.
  - 모델과 뷰의 매개체라는 점에서 컨트롤러와 유사하지만, 뷰에 직접 연결되는 대신 인터페이스를 통해 상호작용한다는 차이가 존재합니다.

<br/>

## M-V-P의 상호작용

MVC와 동일하게 쇼핑 리스트 앱을 예시로 들겠습니다.

- **모델**은 앱이 포함해야 할 데이터가 무엇인지를 정의합니다.
  데이터가 변경되면 모델은 정보를 가진 채 **프리젠터**에게 알리고, 프리젠터가 뷰를 갱신합니다.
  모델은 리스트 항목이 포함해야 하는 데이터(품목, 개수, 가격 등)와 이미 존재하는 항목이 무엇인지를 지정합니다.
- **뷰**는 앱의 데이터를 화면에 표시하고, 사용자의 입력 이벤트(버튼 클릭, 항목 추가/제거 등)를 감지하여 **프리젠터**에 전달합니다.
  쇼핑 리스트 앱에서 뷰는 항목이 사용자에게 어떻게 보일지 정의하고, 사용자가 입력한 값을 프리젠터에게 전송합니다.
- **프리젠터**는 뷰로부터 전달받은 사용자 입력에 따라 모델을 업데이트하고, 모델의 변경 사항을 뷰에 반영하는 로직을 포함합니다.
  예를 들어, 사용자가 항목 추가 버튼을 클릭하면 뷰가 이벤트와 함께 입력 값을 프리젠터에 전달하고,
  프리젠터는 모델에 항목을 추가한 뒤 변경된 리스트를 다시 뷰로 전송해 화면을 갱신합니다.
  또한, 항목을 알파벳 순서나 가격 순서로 정렬해야 할 때는, 프리젠터가 정렬 로직을 수행하거나 모델에서 정렬된 데이터를 가져와 뷰에 전송합니다.

<br/>

## MVC와의 비교

MVP는 MVC의 단점인 뷰와 모델의 의존성을 프리젠터를 통해 해결합니다. 모델과 뷰가 분리되어 있고, 오직 프리젠터를 통해서만 상태나 변화를 알려줄 수 있습니다.

다만, 뷰와 프리젠터 사이의 의존성이 높다는 단점 또한 가집니다. 뷰와 프리젠터는 1:1 관계이기 때문에 프리젠터 재사용이 불가능하며, 기능이 많아질수록 프리젠터가 거대해지는 단점 또한 존재합니다.

<br/>

<br/>

> 참고
>
> - https://frtt0608.tistory.com/94
> - https://beomy.tistory.com/43
> - https://velog.io/@kyeun95/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-MVP-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80
