# MVVM 패턴

> 프로그램의 비즈니스 로직과, 프레젠테이션 로직을 UI로 명확하게 분리하는 패턴

- 비즈니스 로직 & 프레젠테이션 로직
  프리젠테이션 로직이란 말 그래도 보여주기 위한 로직을 말한다. 즉 화면상의 디자인 구성을 위한 로직을 일컫는 말로써, 게시판에서의 표시하기 위한 for(or while)문 등의 사용이 여기에 해당한다.
  반면에 비즈니스 로직이라는 것은 어떠한 특정한 값을 얻기 위해 데이터의 처리를 수행하는 응용프로그램의 일부를 말한다. 즉 원하는 값을 얻기 위해서 백엔드에서 일어나는 각종 처리를 일컫는 말이다.
  출처: https://bohyeon2.tistory.com/74

MVVM 패턴도 모델과 뷰는 동일하나, View Model이 존재합니다. 뷰와 뷰 모델 사이의 의존성을 없애 각각의 부분이 독립적인 패턴입니다.

<br/>

## 구성 요소

- **모델**: 애플리케이션의 핵심 데이터와 비즈니스 로직을 나타냅니다.
  - 데이터 저장소, 네트워크 연동, 유효성 검사 등을 독립적으로 처리하며, 뷰 모델과만 통신합니다.
  - 뷰에는 직접 변경을 알리지 않고, 뷰 모델을 통해 간접적으로 상태를 전달합니다.
- **뷰**: 사용자에게 보여지는 애플리케이션의 UI로, 레이아웃과 화면을 처리합니다.
  - 뷰 모델이 노출한 속성(Property)과 명령(Command)에 데이터 바인딩(Data Binding) 방식으로 연결됩니다.
  - 가능한 한 로직 없이 바인딩된 데이터와 이벤트만 처리하고, 사용자 입력을 뷰 모델로 전달합니다.
- **뷰 모델**: 모델과 뷰 사이의 데이터/명령 매개체 역할을 합니다.
  - 모델 객체를 래핑하여 뷰가 바인딩할 수 있는 속성과 컬렉션을 제공합니다.
  - 뷰의 명령은 커맨드 패턴으로 받아 모델을 업데이트하고 결과를 다시 뷰에 반영합니다.

<br/>

## M-V-VM의 상호작용

MVC, MVP와 동일하게 쇼핑 리스트 앱을 예시로 들겠습니다.

- **모델**은 앱이 포함해야 할 데이터가 무엇인지를 정의합니다.
  데이터가 변경되면 모델은 직접 뷰에게 알리지 않고, 바인딩된 뷰 모델에게 상태 변화를 전달합니다.
  쇼핑 리스트 모델은 리스트 항목의 구조(품목, 개수 등)와 현재 항목 목록을 관리합니다.
- **뷰**는 화면에 표시할 UI 레이아웃과 바인딩을 정의합니다.
  뷰는 뷰 모델이 노출한 속성(목록, 합계 등)과 명령(추가, 제거, 정렬 등)에 데이터 바인딩으로 연결되어, 사용자 입력 이벤트(버튼 클릭, 항목 추가 등)를 자동으로 뷰 모델에 전달합니다.
  쇼핑 리스트 뷰는 항목 목록을 렌더링하고, 사용자가 “추가” 버튼을 누르면 뷰모델의 추가 명령을 실행합니다.
- **뷰 모델**은 모델과 뷰 사이의 데이터 및 명령 매개체 역할을 합니다.
  모델에서 가져온 리스트 데이터를 뷰에 노출하고, 뷰의 바인딩 이벤트를 처리해 모델을 업데이트하거나, 모델 상태를 다시 뷰로 전달합니다.
  예를 들어, 사용자가 “항목 추가” 버튼을 클릭하면
  1. 뷰 모델이 새로운 항목 데이터를 모델에 전달
  2. 모델이 내부 컬렉션을 갱신
  3. 뷰 모델이 모델의 변경을 감지해 바인딩된 뷰에 자동으로 목록 갱신 알림을 보냅니다.

     또한, 알파벳순/가격순 정렬 같은 UI 전용 로직은 뷰모델에서 수행하고, 결과를 다시 뷰에 바인딩해 즉시 반영할 수 있습니다.

<br/>

## MVC, MVP와의 비교

MVVM은 의존성 문제를 해결하여 테스트가 수월해집니다. 또한 뷰와 뷰 모델이 1:N 관계이기 때문에 중복되는 로직을 모듈화하여 여러 뷰에 재사용할 수 있습니다.

다만 설계가 복잡하며, 뷰 모델이 비대해질 수 있다는 단점을 지닙니다. 데이터 바인딩으로 인한 메모리 소모 또한 심합니다.

<br/>

<br/>

> 참고
>
> - https://velog.io/@kyeun95/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-MVVM-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80
> - https://beomy.tistory.com/43
