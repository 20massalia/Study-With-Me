# PCB (Process Control Block)

PCB(프로세스 제어 블럭)는 OS에서 프로세스를 관리하기 위해 해당 프로세스의 상태 정보를 담고 있는 자료구조입니다.

프로세스를 컨텍스트 스위칭 할때 기존 프로세스의 상태를 다른 곳에 저장해야 다음에 똑같은 작업을 이어서 할 수 있습니다.
또한, 새로 해야할 작업의 상태 또한 알아야 어디서부터 다시 작업을 시작할지 결정할 수 있습니다.

즉, PCB는 프로세스 스케쥴링을 위해 프로세스에 관한 모든 정보를 저장하는 임시 저장소입니다.

![PCB 동작](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FdxYApr%2Fbtq2plns3mV%2FAAAAAAAAAAAAAAAAAAAAAHuI0U-zjYU2G5SelhznDO_ayX3VqgD0uGF__umEe4qB%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Du8Nhbc9%252Byjx%252F48celO7Hj7LZfDk%253D)

따라서 운영체제는 PCB에 담긴 프로세스 정보를 통해 프로세스를 관리하고, 프로세스의 실행 상태를 파악하고, 우선순위를 조정하며, 스케쥴링을 수행하고, 다른 프로세스와의 동기화를 제어합ㄴ디ㅏ.

![PCB 블럭](https://user-images.githubusercontent.com/52024566/110055961-4a054c80-7da1-11eb-9749-a4b8c6c41729.png)

- 포인터 (Pointer) : 프로세스의 현재 위치를 저장하는 포인터 정보
- 프로세스 상태 (Process state) : 프로세스의 각 상태 - 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated) 를 저장
- 프로세스 아이디 (Process ID, PID) : 프로세스 식별자를 지정하는 고유한 ID
- 프로그램 카운터 (Program counter) :  프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터를 저장
- 레지스터 (Register) : 누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보
- 메모리 제한 (Memory Limits) : 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보
- 열린 파일 목록 (List of open file) : 프로세스를 위해 열린 파일 목록

## Context Switching 과정

![Context Switching 과정](https://velog.velcdn.com/images/yoonuk/post/ba5772b3-73ca-40fa-b7f1-640e53e9d483/image.png)

1. CPU는 Process P1을 실행한다 (Executing)
2. 일정 시간이 지나 Interrupt 또는 system call이 발생한다. (CPU는 idle 상태)
3. 현재 실행 중인 Process P1의 상태를 PCB1에 저장한다. (Save state into PCB1)
4. 다음으로 실행할 Process P2를 선택한다. (CPU 스케줄링)
5. Process P2의 상태를 PCB2에서 불러온다. (Reload state from PCB2)
6. CPU는 Process P2를 실행한다. (Executing)
7. 일정 시간이 지나 Interrupt 또는 system call이 발생한다. (CPU는 idle 상태)
8. 현재 실행 중인 Process P2의 상태를 PCB2에 저장한다. (Save state into PCB2)
9. 다시 Process P1을 실행할 차례가 된다. (CPU 스케줄링)
10. Process P1의 상태를 PCB1에서 불러온다. (Reload state from PCB1)
11. CPU는 Process P1을 중간 시점 부터 실행한다. (Executing)

## Context Switching Overhead

이러한 컨텍스트 스위칭 과정은 사용자로금 빠른 반응성과 동시성을 제공하지만, 실행되는 프로세스의 변경 과정에서 프로세스의 상태, 레지스터 값 등이 저장되고 불러오는 등의 작업이 수행하기 때문에 시스템에 부담을 주게됩니다.

위의 컨텍스트 스위칭 과정 그림을 보면 P1이 Execute에서 idle이 될 때 P2가 바로 Execute가 되지 않고 idle을 상태에 조금 있다가 Execute가 되는걸 볼 수 있습니다. 이 간극이 컨텍스트 스위칭 오버헤드(overhead)입니다.

![Context Switching Overhead](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR9KBam_R8zpltmVa0gsYNPWIDzryExOckhuQ&s)

컨텍스트 스위칭 과정에서 PCB에 저장하고 복원하는데 비용이 발생하며, 프로세스 자체가 교체되는 것이니 CPU 캐시 메모리 데이터가 무효화됩니다. 이 과정에서는 메모리 접근 시간이 늘고, 성능저하가 발생할 수 있습니다.

컨텍스트 스위칭은 프로세스 뿐만 아니라 스레드 끼리도 일어납니다.

컨텍스트 스위칭 오버헤드라는 변수 때문에 스레드 교체 과정에서 과하게 오버헤드가 발생하면 오히려 멀티 스레드가 싱글 스레드보다 성능이 떨어지는 현상이 발생할 수 있습니다. 
즉, 항상 멀티스레드 방식이 싱글 스레드보다 성능이 좋은 것은 아닙니다.

이러한 각 스레드에 대한 정보도 PCB처럼 TCB(Thread Control Block)으로 PCB 내부에 있습니다.
또한, 이러한 스레드 간의 자원공유를 뮤텍스, 세마포어와 같은 동기화 기법을 사용해 관리합니다.

## Reference

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#pcb_process_control_block
https://applefarm.tistory.com/105
https://melodist.github.io/docs/OS/ContextSwitching