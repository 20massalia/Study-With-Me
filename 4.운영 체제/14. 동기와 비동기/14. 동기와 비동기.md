# 동기와 비동기, 블로킹과 논블로킹

## 1. 동기(Synchronous)와 비동기(Asynchronous)란?
- **동기**: 작업이 순차적으로 진행되며, 호출자는 결과가 반환될 때까지 대기합니다. 예측 가능한 흐름, Blocking I/O와 자주 연계됨.
- **비동기**: 작업 완료와 관계없이 다음 작업을 바로 진행합니다. 결과는 콜백, 이벤트, Promise 등으로 전달. Non-blocking I/O와 자주 연계됨.

![동기비동기](https://velog.velcdn.com/images/4775614/post/6b948db8-0c70-4016-9805-7a92e35e252f/image.png)

## 2. 블로킹(Blocking)과 논블로킹(Non-blocking) 차이
- **블로킹**: 함수 호출이 반환될 때까지 현재 스레드가 멈춤. CPU가 대기 상태가 됨.
- **논블로킹**: 함수 호출이 즉시 반환, 스레드는 계속 실행. 결과가 준비되면 별도 방식(이벤트, 콜백 등)으로 전달.

## 3. 동기/비동기와 블로킹/논블로킹의 조합
- 동기+블로킹: 가장 일반적. 함수가 끝날 때까지 대기.
- 동기+논블로킹: 호출자는 즉시 반환받지만, 결과를 직접 폴링하거나 별도 확인 필요. 실질적으로 의미가 크지 않음.
- 비동기+블로킹: 작업을 요청한 뒤, 결과를 기다리며 블로킹됨. 비동기의 장점이 사라져 의미가 없음.
- 비동기+논블로킹: 가장 효율적. 작업 요청 후 바로 다음 작업 진행, 결과는 콜백/이벤트 등으로 수신.

![동기/비동기와 블로킹/논블로킹의 조합](https://velog.velcdn.com/images/jjh0526/post/582c8d27-10ca-40d5-ad7f-6b36038f9ab3/image.png)

## 4. I/O 멀티플렉싱이란?
여러 I/O 스트림(소켓, 파일 등)을 동시에 감시하여, 준비된 스트림만 처리하는 방식입니다. 대표적 시스템 콜로 select, poll, epoll, kqueue 등이 있습니다. 하나의 스레드/프로세스가 여러 I/O를 효율적으로 처리할 수 있습니다.

- 이벤트 루프 기반 서버(예: Node.js, nginx)에서 활용
- 비동기/논블로킹 I/O와 결합해 고성능 네트워크 서버 구현

![멀티플렉싱](https://velog.velcdn.com/images/im2sh/post/00f41fd3-acf2-4a59-8f3a-07ee81ee98d8/image.png)

## 5. 논블로킹 I/O 결과 수신 방법
- **폴링(Polling)**: 주기적으로 상태를 확인
- **콜백(Callback)**: 다른 작업의 완료 여부나 결과에 대한 후처리를 위해 이용되는 방식
- **이벤트 루프(Event Loop)**: 준비된 I/O 이벤트를 감지해 처리
- **Future/Promise**: 결과가 준비되면 값을 반환

즉, 논블로킹 I/O는 결과가 준비될 때까지 스레드를 멈추지 않고, 이벤트/콜백/폴링 등으로 결과를 수신합니다.

## Reference
https://wildeveloperetrain.tistory.com/104
https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC